## 재택근무 관리 시스템(3차 프로젝트/4인팀플)

프론트앤드 : pug

백앤드 : NodeJS

DB : MongoDB

빌드 시스템 : webpack



NodeJS : 브라우저 밖의 자바스크립트(사용자가 브라우저 밖에서도 자바스크립트를 이용해 서버를 만들 수 있고 파일 시스템과 연동할 수 있다.) 원래 자바스크립트는 브라우저에 종속되어 있었는데 그것을 극복 할 수 있게 도와준게 NodeJS이다.

**NodeJS를 사용하는 이유**

1.프론트 앤드와 백앤드 둘다 자바스크립트를 사용하고 싶어서

2.내가 기본적인게 셋팅되어 있지 않고 커스터마이징 하고 싶을 때는 자바스크립트가 (Django/Python),(lalabel/PHP)보다 좋다. 작은 블록을 쌓아서 큰 성을 짓는다고 생각하면 됨

3.내가 많은 데이터를 움직여야 할때 좋다.(Database 생성,삭제)/ 엄청 많은 사람들이 데이터를 보내고 받고/알림/ 실시간 등을 처리할 때는 NodeJS가 좋은 퍼포먼스를 보여줄 수 있다.(내가 데이터를 다뤄야 할 때)



자, 서버란 무엇일까?

서버란 컴퓨터(인터넷에 연결된 컴퓨터)

소프트웨어적인 서버는 뭐야? 인터넷(네트워크)에 연결된 한 덩어리의 코드이다.

URL에 응답하고 접속을 허락하는 일을 한다.



내가 URL을 통해 페이지를 요청하면 어딘가에 있을 서버에 저장된 데이터가 나에게 보내진다.



정리하자면 기본적으로 서버는 2가지로 나눌 수 있다.

1.물리적으로 늘 켜져있는 컴퓨터

2.인터넷에 연결돼 있고 내 접속 요청에 응답하는 컴퓨터

프라이빗한 서버를 집에 직접 놔둘 수 있겠지?

서버란 접속을 받아주는 무언가라고 할 수 있겠지?

어떤 접속을 듣고 있는 무언가지



**Express란 무엇일까?**

익스프레스는 프레임워크라고 할 수 있다.

이미 많은 사람들이 우리를 위해 훌륭한 기능들을 만들어놔서 우리가 그걸 가져다 쓰면 됨

이때 NodeJS로 서버를 만들 수 있게 도와주는 프레임워크가 Express라고 할 수 있다.

Express를 이용해서 단 몇 줄의 코드로 서버를 만들 수 있다.



이미 많은 프레임 워크들이 있어~ 예를들어 Django는 Python에서 작동하는 프레임워크라고 할 수 있지

Rails는 Ruby로 된 프레임워크, Larabel은 PHP로 된 프레임워크

이것들 모두가 유저들의 개발을 도와주는 프레임워크라고 할 수 있다.



NodeJS위에서 작동하는 Express는 안정적이기 때문에 많은 사람들이 쓰고 있다.



### 본격적으로 Start

1.nodeJS 다운받기

node -v

2.npm 설치(세상에 좋은 사람들이 express 같은걸 만들었어 그러면 이런걸 공유하게 싶겠지? 그런데 기존의 방식은 우리가 다운로드 받으로 사이트를 들어가야 하고 기다려야 하고 이런 작업들을 하기 싫은거야 그래서 npm이나 yarn이 나온것)

NodeJS 진영의 중심이 npm이라고 할 수 있지. 그 진영에 들어가서 필요한 패키지를 다운로드 받는 것 그 패키지에는 express,react,react-native 같은 것들이 있는 것임

자바스크립트로 프론트앤드, 백앤드를 만드는 각자의 패키지를 담아서 올리는 곳

그래서 우리가 다운로드 받고 업데이트 하고



npm -v

NodeJS를 다운로드 받으면 npm은 자동으로 설치가 이루어짐(패키지를 자동으로 공유하고 받을 수 있어야 하니까!)



npm이 정한 방식으로 프로젝트를 시작하는 거지

1.npm init을 치면 패키지의 이름 등을 작성하라고 하지? 이제 내가 패키지를 구성함으로써 웹사이트를 만드는거야 오케이?

package.json은 javascript에서 정보를 담는 방식이다.

npm install express할때 꼭 package.json이 있는 폴더 내에서 설치를 하자

express도 다른 것들에 의존하고 있다. 그래서 50개의 패키지를 같이 가져오는 것

설치를하고 node_modules를 지워도 package.json에 이미 express가 명시되어 있기 때문에

다시 npm install만 해도 package.json에 명시되어 있는 의존성 dependencies를 설치하게 된다.



package-lock.json 파일은 package.json의 보안에 관련된 사항을 명시해주고 있음 그래서 이것도

.gitignore에 명시해주는게 좋음

<hr>

const express = require("express"); //express 모듈파일을 블러온다. express 모듈파일은 또 다른 모듈들을 참고하고 있음 => 즉, 작은 블록을 쌓아서 큰 성을 쌓는다! 설치한 다음에 require=import하면 된다.

const app = express(); // 그런 다음에 어플리케이션을 만드는 거지, express를 실행시켜 app에 담는다.

const PORT = 4000;

function handleListening() {

 console.log(`${PORT} Server ready...✅`);

}



app.listen(PORT, handleListening); // app아 너 듣고 있니? express 서버를 갖게 됬어!

<hr>

GET 요청은 바디가 없어서 정보를 담아서 전달하기에는 부족하다.

POST 요청은 정보를 담아서 전달할 수 있다.

<hr>

const express = require("express");

const app = express();



const PORT = 4000;



function handleListening() {

 console.log(`${PORT} Server ready...✅`);

}



function handleHome(req, res) {

 res.send("여기는 홈 페이지 입니다.");

}



function handleProfile(req, res) {

 res.send("여기는 프로파일 페이지 입니다.");

}



app.get("/", handleHome);

app.get("/profile", handleProfile);



app.listen(PORT, handleListening);     

//여기까지가 기본적으로 서버에 대해 요청과 응답이 이루어지는 기본적인 구조

하지만 그 다음부터는 res.send() 안에 완전한 html,css 파일을 넣어서 보내줄꺼다!

서버를 생성하고 route를 생성하고 그리고 그것에 대해 응답하는 것까지 했다.

여기까지 NodeJS, express를 이용해 코드 20줄로 만든것

그 다음부터는 Babel을 이용해서 Javascript 코드를 update하는데 쓸 거다.

왜냐면 최신의 Javascript 코드를 쓰고 싶기 때문에...

<hr>

Babel이란게 뭘까?

최신의 Javascript 코드를 예전의 Javascript 코드로 변환해준다!!



그니까 우리가 기본적으로 최신의 Javascript 코드를 작성하면 babel은 이걸 브라우저가 이해할 수 있는 표준의 코드로 바꿔주는 역할을 한다.



Babel은 많은 Loader를 가지고 있는데 이건 한마디로 babel을 쓰기 위해서 설치해야하는 모듈이라고 생각하면 될듯?(내생각)

Babel node는 babel을 NodeJS에서 쓰기 위해서 필요함



statge-3에 해당하는 걸 쓰면 브라우저가 절반만 받아들여질 것이다.

state-0는 완전 실험적인 걸 얻게 될것



하지만 우리는 preset-env를 쓸것임(이건 완전 실험적인것도 아니고 브라우저가 어느정도 이해를 함)



Babel도 우선 Nodejs가 어떻게 작동해야 하는지 알아야 하니까 @babel/core, @babel/node, @babel/preset-env등을 설치해준다.

npm install @babel/core

npm install @babel/node

npm install @babel/preset-env



npm install nodemon



일단 파일 하나 생성 .babelrc

.babelrc 파일생성해서 거기에 **우리가 원하는 NodeJS와 Javascript에 대한 설정과 관련된 것들을 넣어줄 것임



예를들어 이거야, "Babel아 넌 이런 preset을 가질꺼야"



package.json 의 start 부분에 추가해줄 것임

{

 "presets": [

  [

   "@babel/preset-env",

   {

​    "useBuiltIns": "usage",

​    "corejs": 3

   }

  ]

 ]

}

npm install --save core-js@3

.babelrc 파일의 preset에 내가 corejs:3버전을 쓴다고 했기 때문에 설치도 3버전을 설치해야 한다.



https://babeljs.io/docs/en/babel-preset-env





babel이 코드를 변환하면 우리가 작성한 최신의 자바스크립트 코드가 못생긴 코드로 바뀌고 그런 다음 node.js로 실행해주는 것이다.



이제 import express from "express"; 로 바꿔줘도 됨



npm start하면 서버가 가동 될 것임



express에 대해서 알아 둬야 할게 있어!

express에서 middleware라는 녀석은 처리가 끝날 때까지 연결되어있는 거라고 이해하면 됨

처리가 끝날 때까지 연결되어 있는 녀석 = middleware

그럼 request가 어떻게 시작돼고 



app.get("/")에서  슬래쉬 부분이 route의 시작이라고 할 수 있다. 슬래쉬만 있으면 처음 초기 home을 찾는다.



보통 연결은 그 흐름이 간단히 이루어 지지 않는다.

보통 중간에 뭔가가 있게 된다. middleware

유저와 마지막 응답 사이에!!!

그래서 express에서 모든 함수는 middleware가 될 수 있다.



const betweenHome = (req,res,next) =>{

console.log("미들웨어 한 번 거치고 그다음 next인 handleHome 함수 호출")

next();

}



양파를 생각해봐 양파의 껍질은 여러겹이지? 그 가장 바깥쪽이 사용자의 request라고 생각하면 그 다음 안쪽층은 middleware라고 생각하고 양파의 가장 중심이 마지막 응답이라고 생각해봐

이렇게 중간에서 함수들이 middleware 역할을 해줄 수 있다. 이게 날 편하게 만들어준다.

이런걸로 내가 로그인을 체크 할 수 있고

파일을 전송할 때 중간에서 가로챌 수도 있고오

그 middleware는 어딘가로 upload하겠지?

로그를 작성하는 middleware도 작성 가능

내가 만약 모든 요청에 대한 정보를 로그로 남기고 싶다면 그런 middleware를 작성하면 되는것



지금은 쉽게 betweenHome은 / 에 대해서만 미들웨어로 썼잖아? 그래서 하나의 route에만 미들웨어를 씀

app.use(betweenHome);   : 기본적으로 웹사이트에서 일어아는 모든 것에 대해 표시, 순서 중요!



접속이 있을 때

위에서부터 아래로 실행이 된다.

그래서 app.use(betweenHome);을 내가 다음에 쓰고 싶은 route 바로 직전에 위치 시켜놓던가 다음에 위치 시켜놓던가 위치 중요!



app.get("/",handleHome);

app.use(betweenHome);

app.get("/profile",handleProfile);



이렇게 돼있을때 미들웨어는 /profile에 대해서만 작동함





이제 Morgan이라는 미들웨어를 설치해보자

morgan은 logging에 도움을 주는 미들웨어

npm install morgan



index.js파일에서 import morgan from "morgan"; 선언



app.use(morgan("tiny"));

app.use(morgan("combined"));

app.use(morgan("dev"));



helmet이라는 미들웨어를 설치해보자

helmet 미들웨어는 NodeJS 앱의 보안에 도움이 되는 미들웨어

npm install helmet



index.js 파일에 import helmet from "helmet"; 추가



이건 뭐 보여주는건 많이 없지만 그냥 앱보안을 위해서 필요한거라고 생각하면 됨 습관을 위해서



미들웨어는 가끔은 연결을 끊을 수가 있다.



const middleware = (req,res,next)=>{

res.send("not happening");

}



위와같이 작성해 놓고 next(); 이렇게 안해주면 그 다음 함수까지 호출못하고 연결을 끊을 수 있다.





이제 2개 미들웨어만 남음

cookie-parser , body-parser 둘다 express의 middleware

이름 그대로 쿠키와 바디를 다루는 미들웨어!



기본적으로 누군가 form을 채워서 전송을 한다면 이 form은 서버에 의해서 받아져야만 한다. 특정한 형태로..

form을 받았을 때 그 데이터를 가지고 있는 request object에 접근할 수 있길 원해 그걸 위해 일단 npm install body-parser 설치 이건 body로부터 정보를 얻을 수 있게 해주는 것



npm install cookie-parser

cookie에 유저 정보를 저장



import bodyParser from "body-parser"

import cookieParser from "cookie-parser"



app.use(cookieParser());   // 이게 유저로부터 받은 cookie를 서버가 이해하는 방법

app.use(bodyparser());     // 이게 서버가 우리가 보내는 데이터의 정보의 형식을 알 수 있는 라인



body-parser에는 우리가 지정해야할 옵션이 있다. text라던지 urlencoded라던지

왜냐면 우리가 무엇을 전송할 때 서버가 무엇을 전송하는지 알 수 있어야 하니까!

우리가 json을 보낼 때 서버가 json을 이해하길 바래야겠지?



우리가 일반적인 html form을 전송한다면 서버가 urlencoded라는 걸 이해하길 바래야한다.

app.use(bodyParser.json());   //내가 보내는 json 데이터 서버가 이해할 수 있게끔 해줌

app.use(bodyParser.urlencoded({extended:true}));   // 내가 보내는 html form 서버가 이해할 수 있게끔



morgan이 기록해주고