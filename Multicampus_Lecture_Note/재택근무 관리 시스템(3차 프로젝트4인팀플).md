## 재택근무 관리 시스템(3차 프로젝트/4인팀플)

프론트앤드 : pug

백앤드 : NodeJS

DB : MongoDB

빌드 시스템 : webpack



NodeJS : 브라우저 밖의 자바스크립트(사용자가 브라우저 밖에서도 자바스크립트를 이용해 서버를 만들 수 있고 파일 시스템과 연동할 수 있다.) 원래 자바스크립트는 브라우저에 종속되어 있었는데 그것을 극복 할 수 있게 도와준게 NodeJS이다.

**NodeJS를 사용하는 이유**

1.프론트 앤드와 백앤드 둘다 자바스크립트를 사용하고 싶어서

2.내가 기본적인게 셋팅되어 있지 않고 커스터마이징 하고 싶을 때는 자바스크립트가 (Django/Python),(lalabel/PHP)보다 좋다. 작은 블록을 쌓아서 큰 성을 짓는다고 생각하면 됨

3.내가 많은 데이터를 움직여야 할때 좋다.(Database 생성,삭제)/ 엄청 많은 사람들이 데이터를 보내고 받고/알림/ 실시간 등을 처리할 때는 NodeJS가 좋은 퍼포먼스를 보여줄 수 있다.(내가 데이터를 다뤄야 할 때)



자, 서버란 무엇일까?

서버란 컴퓨터(인터넷에 연결된 컴퓨터)

소프트웨어적인 서버는 뭐야? 인터넷(네트워크)에 연결된 한 덩어리의 코드이다.

URL에 응답하고 접속을 허락하는 일을 한다.



내가 URL을 통해 페이지를 요청하면 어딘가에 있을 서버에 저장된 데이터가 나에게 보내진다.



정리하자면 기본적으로 서버는 2가지로 나눌 수 있다.

1.물리적으로 늘 켜져있는 컴퓨터

2.인터넷에 연결돼 있고 내 접속 요청에 응답하는 컴퓨터

프라이빗한 서버를 집에 직접 놔둘 수 있겠지?

서버란 접속을 받아주는 무언가라고 할 수 있겠지?

어떤 접속을 듣고 있는 무언가지



**Express란 무엇일까?**

익스프레스는 프레임워크라고 할 수 있다.

이미 많은 사람들이 우리를 위해 훌륭한 기능들을 만들어놔서 우리가 그걸 가져다 쓰면 됨

이때 NodeJS로 서버를 만들 수 있게 도와주는 프레임워크가 Express라고 할 수 있다.

Express를 이용해서 단 몇 줄의 코드로 서버를 만들 수 있다.



이미 많은 프레임 워크들이 있어~ 예를들어 Django는 Python에서 작동하는 프레임워크라고 할 수 있지

Rails는 Ruby로 된 프레임워크, Larabel은 PHP로 된 프레임워크

이것들 모두가 유저들의 개발을 도와주는 프레임워크라고 할 수 있다.



NodeJS위에서 작동하는 Express는 안정적이기 때문에 많은 사람들이 쓰고 있다.



### 본격적으로 Start

1.nodeJS 다운받기

node -v

2.npm 설치(세상에 좋은 사람들이 express 같은걸 만들었어 그러면 이런걸 공유하게 싶겠지? 그런데 기존의 방식은 우리가 다운로드 받으로 사이트를 들어가야 하고 기다려야 하고 이런 작업들을 하기 싫은거야 그래서 npm이나 yarn이 나온것)

NodeJS 진영의 중심이 npm이라고 할 수 있지. 그 진영에 들어가서 필요한 패키지를 다운로드 받는 것 그 패키지에는 express,react,react-native 같은 것들이 있는 것임

자바스크립트로 프론트앤드, 백앤드를 만드는 각자의 패키지를 담아서 올리는 곳

그래서 우리가 다운로드 받고 업데이트 하고



npm -v

NodeJS를 다운로드 받으면 npm은 자동으로 설치가 이루어짐(패키지를 자동으로 공유하고 받을 수 있어야 하니까!)



npm이 정한 방식으로 프로젝트를 시작하는 거지

1.npm init을 치면 패키지의 이름 등을 작성하라고 하지? 이제 내가 패키지를 구성함으로써 웹사이트를 만드는거야 오케이?

package.json은 javascript에서 정보를 담는 방식이다.

npm install express할때 꼭 package.json이 있는 폴더 내에서 설치를 하자

express도 다른 것들에 의존하고 있다. 그래서 50개의 패키지를 같이 가져오는 것

설치를하고 node_modules를 지워도 package.json에 이미 express가 명시되어 있기 때문에

다시 npm install만 해도 package.json에 명시되어 있는 의존성 dependencies를 설치하게 된다.



package-lock.json 파일은 package.json의 보안에 관련된 사항을 명시해주고 있음 그래서 이것도

.gitignore에 명시해주는게 좋음

<hr>

const express = require("express"); //express 모듈파일을 블러온다. express 모듈파일은 또 다른 모듈들을 참고하고 있음 => 즉, 작은 블록을 쌓아서 큰 성을 쌓는다! 설치한 다음에 require=import하면 된다.

const app = express(); // 그런 다음에 어플리케이션을 만드는 거지, express를 실행시켜 app에 담는다.

const PORT = 4000;

function handleListening() {

 console.log(`${PORT} Server ready...✅`);

}



app.listen(PORT, handleListening); // app아 너 듣고 있니? express 서버를 갖게 됬어!

<hr>

GET 요청은 바디가 없어서 정보를 담아서 전달하기에는 부족하다.

POST 요청은 정보를 담아서 전달할 수 있다.

<hr>

const express = require("express");

const app = express();



const PORT = 4000;



function handleListening() {

 console.log(`${PORT} Server ready...✅`);

}



function handleHome(req, res) {

 res.send("여기는 홈 페이지 입니다.");

}



function handleProfile(req, res) {

 res.send("여기는 프로파일 페이지 입니다.");

}



app.get("/", handleHome);

app.get("/profile", handleProfile);



app.listen(PORT, handleListening);     

//여기까지가 기본적으로 서버에 대해 요청과 응답이 이루어지는 기본적인 구조

하지만 그 다음부터는 res.send() 안에 완전한 html,css 파일을 넣어서 보내줄꺼다!

서버를 생성하고 route를 생성하고 그리고 그것에 대해 응답하는 것까지 했다.

여기까지 NodeJS, express를 이용해 코드 20줄로 만든것

그 다음부터는 Babel을 이용해서 Javascript 코드를 update하는데 쓸 거다.

왜냐면 최신의 Javascript 코드를 쓰고 싶기 때문에...

<hr>

Babel이란게 뭘까?

최신의 Javascript 코드를 예전의 Javascript 코드로 변환해준다!!



그니까 우리가 기본적으로 최신의 Javascript 코드를 작성하면 babel은 이걸 브라우저가 이해할 수 있는 표준의 코드로 바꿔주는 역할을 한다.



Babel은 많은 Loader를 가지고 있는데 이건 한마디로 babel을 쓰기 위해서 설치해야하는 모듈이라고 생각하면 될듯?(내생각)

Babel node는 babel을 NodeJS에서 쓰기 위해서 필요함



statge-3에 해당하는 걸 쓰면 브라우저가 절반만 받아들여질 것이다.

state-0는 완전 실험적인 걸 얻게 될것



하지만 우리는 preset-env를 쓸것임(이건 완전 실험적인것도 아니고 브라우저가 어느정도 이해를 함)



Babel도 우선 Nodejs가 어떻게 작동해야 하는지 알아야 하니까 @babel/core, @babel/node, @babel/preset-env등을 설치해준다.

npm install @babel/core

npm install @babel/node

npm install @babel/preset-env



npm install nodemon



일단 파일 하나 생성 .babelrc

.babelrc 파일생성해서 거기에 **우리가 원하는 NodeJS와 Javascript에 대한 설정과 관련된 것들을 넣어줄 것임



예를들어 이거야, "Babel아 넌 이런 preset을 가질꺼야"



package.json 의 start 부분에 추가해줄 것임

{

 "presets": [

  [

   "@babel/preset-env",

   {

​    "useBuiltIns": "usage",

​    "corejs": 3

   }

  ]

 ]

}

npm install --save core-js@3

.babelrc 파일의 preset에 내가 corejs:3버전을 쓴다고 했기 때문에 설치도 3버전을 설치해야 한다.



https://babeljs.io/docs/en/babel-preset-env





babel이 코드를 변환하면 우리가 작성한 최신의 자바스크립트 코드가 못생긴 코드로 바뀌고 그런 다음 node.js로 실행해주는 것이다.



이제 import express from "express"; 로 바꿔줘도 됨



npm start하면 서버가 가동 될 것임



express에 대해서 알아 둬야 할게 있어!

express에서 middleware라는 녀석은 처리가 끝날 때까지 연결되어있는 거라고 이해하면 됨

처리가 끝날 때까지 연결되어 있는 녀석 = middleware

그럼 request가 어떻게 시작돼고 



app.get("/")에서  슬래쉬 부분이 route의 시작이라고 할 수 있다. 슬래쉬만 있으면 처음 초기 home을 찾는다.



보통 연결은 그 흐름이 간단히 이루어 지지 않는다.

보통 중간에 뭔가가 있게 된다. middleware

유저와 마지막 응답 사이에!!!

그래서 express에서 모든 함수는 middleware가 될 수 있다.



const betweenHome = (req,res,next) =>{

console.log("미들웨어 한 번 거치고 그다음 next인 handleHome 함수 호출")

next();

}



양파를 생각해봐 양파의 껍질은 여러겹이지? 그 가장 바깥쪽이 사용자의 request라고 생각하면 그 다음 안쪽층은 middleware라고 생각하고 양파의 가장 중심이 마지막 응답이라고 생각해봐

이렇게 중간에서 함수들이 middleware 역할을 해줄 수 있다. 이게 날 편하게 만들어준다.

이런걸로 내가 로그인을 체크 할 수 있고

파일을 전송할 때 중간에서 가로챌 수도 있고오

그 middleware는 어딘가로 upload하겠지?

로그를 작성하는 middleware도 작성 가능

내가 만약 모든 요청에 대한 정보를 로그로 남기고 싶다면 그런 middleware를 작성하면 되는것



지금은 쉽게 betweenHome은 / 에 대해서만 미들웨어로 썼잖아? 그래서 하나의 route에만 미들웨어를 씀

app.use(betweenHome);   : 기본적으로 웹사이트에서 일어아는 모든 것에 대해 표시, 순서 중요!



접속이 있을 때

위에서부터 아래로 실행이 된다.

그래서 app.use(betweenHome);을 내가 다음에 쓰고 싶은 route 바로 직전에 위치 시켜놓던가 다음에 위치 시켜놓던가 위치 중요!



app.get("/",handleHome);

app.use(betweenHome);

app.get("/profile",handleProfile);



이렇게 돼있을때 미들웨어는 /profile에 대해서만 작동함





이제 Morgan이라는 미들웨어를 설치해보자

morgan은 logging에 도움을 주는 미들웨어

npm install morgan



index.js파일에서 import morgan from "morgan"; 선언



app.use(morgan("tiny"));

app.use(morgan("combined"));

app.use(morgan("dev"));



helmet이라는 미들웨어를 설치해보자

helmet 미들웨어는 NodeJS 앱의 보안에 도움이 되는 미들웨어

npm install helmet



index.js 파일에 import helmet from "helmet"; 추가



이건 뭐 보여주는건 많이 없지만 그냥 앱보안을 위해서 필요한거라고 생각하면 됨 습관을 위해서



미들웨어는 가끔은 연결을 끊을 수가 있다.



const middleware = (req,res,next)=>{

res.send("not happening");

}



위와같이 작성해 놓고 next(); 이렇게 안해주면 그 다음 함수까지 호출못하고 연결을 끊을 수 있다.





이제 2개 미들웨어만 남음

cookie-parser , body-parser 둘다 express의 middleware

이름 그대로 쿠키와 바디를 다루는 미들웨어!



기본적으로 누군가 form을 채워서 전송을 한다면 이 form은 서버에 의해서 받아져야만 한다. 특정한 형태로..

form을 받았을 때 그 데이터를 가지고 있는 request object에 접근할 수 있길 원해 그걸 위해 일단 npm install body-parser 설치 이건 body로부터 정보를 얻을 수 있게 해주는 것



npm install cookie-parser

cookie에 유저 정보를 저장



import bodyParser from "body-parser"

import cookieParser from "cookie-parser"



app.use(cookieParser());   // 이게 유저로부터 받은 cookie를 서버가 이해하는 방법

app.use(bodyparser());     // 이게 서버가 우리가 보내는 데이터의 정보의 형식을 알 수 있는 라인



body-parser에는 우리가 지정해야할 옵션이 있다. text라던지 urlencoded라던지

왜냐면 우리가 무엇을 전송할 때 서버가 무엇을 전송하는지 알 수 있어야 하니까!

우리가 json을 보낼 때 서버가 json을 이해하길 바래야겠지?



우리가 일반적인 html form을 전송한다면 서버가 urlencoded라는 걸 이해하길 바래야한다.

app.use(bodyParser.json());   //내가 보내는 json 데이터 서버가 이해할 수 있게끔 해줌

app.use(bodyParser.urlencoded({extended:true}));   // 내가 보내는 html form 서버가 이해할 수 있게끔



morgan이 기록해주고



이제부터 슬슬 복잡해지기 시작할 껀데 데이터베이스도 집어 넣어야 하고 설정도 해야 해서

init.js 파일 생성해주고

index.js => app.js 파일로 변경해주자



app.js 에서 app.listen 부분 지워주기



init.js 파일에서 모듈을 불러올 것임



모듈이라는게 있어서 우리 코드를 공유할 수 있다.

다른 파일에서의 코드를 가져다가 사용할 수 있다.



app.js를 init.js에서 사용하는것



app.js 파일 맨 아래에 export default app; 

export default app의 의미는 누군가 내 파일을 불러올 때(import) 내 app object를 주겠다라는 의미

app object라는게 뭔데? 그건 app.use 블라블라 app.get 이런 것들 전부를 의미, 내가 이미 설정한 것들





init.js 파일에서..

import app from "./app";

const PORT = 3000;



const handleListening = ()=>{

console.log(``)

}



app.listen(PORT,handleListening);



이미 application을 app파일에서 가져왔기 때문에 가능



<hr>

router란 route들의 복잡함을 쪼개주는데 사용할 수 있다.

/

/user

/user/profile

/user/changeProfile

등등등



router.js 파일 생성

import express from "express";

const userRouter = express.Router();



userRouter.get("/")

##home(/)에다가 함수를 하나 만들어 줄 것임

두가지 방법이 있는데

#### 1.route랑 분리해서 함수를 하나 만드는 방법

const handleHome = (res,res)=>{

res.send("Here is Home");

}

app.get("/",handleHome);



#### 2.익명의 함수로 만드는 방법 

userRouter.get("/",(req,res)=>{

res.send("Here is Home");

});

 

**둘다 같은건데 2번째꺼는 route안에 들어간거라서 편해보임**





import express from "express";

const userRouter = express.Router();

userRouter.get("/",(req,res)=>{res.send("user index")});

userRouter.get("/edit",(req,res)=>{res.send("user edit")});

userRouter.get("/password",(req,res)=>{res.send("user password")});



그럼 이 router들을 어떻게 app.js 파일에서 사용할까?

router.js 는 기본적으로 많은 route들이 담긴 파일이야

**export  const userRouter = express.Router();**를 해주면 app.js에서 import해와서 쓸 수 있다.



app.js 파일 상단에

import {userRouter} from "./router"; 선언



그리고 app.use("/user",userRouter); 이렇게 코딩

use의 의미는 누군가 /user 경로에 접속하면 userRouter를 사용하겠다. 즉, router 전체를 사용하겠다라는 의미



자 이제 접속을 해보자

localhost:3000/user

localhost:3000/user/edit

localhost:3000/user/password



그다음 MVC 패턴에 대해서 배우겠다.



MVC는 Mode, View, Control을 의미한다.

Model : 데이터

View : 데이터가 어떻게 생겼는지 보여주는 것

Control : 데이터를 보여주게 하는 함수



이건 뭔 설치나 그런걸 하는게 아니라 그냥 섹시한 구조& 패턴을 보여주는 컨셉인거임



이제 URL과 함수를 분리할 것이다.(데이터의 모습에 맞춰서 말야!)

URL에 해당하는 router를 사용하고 실행하는 함수가 Controller가 되겠지



우리가 하는 프로젝트에서는

Model : 데이터베이스 => mongoDB

View : templete => pug

Controller : 데이터 보여주는하는 함수

일단 MVC 에 맞게끔 분리를 해줘야 함



일단 app.js 파일에서 다음과 같은 코드 지워버리기

app.get("/",handleHome);

app.get("/profile",handleProfile)

handleHome,handleProfile 함수도 지워버리기





그 다음 userRouter.js 파일 생성하기

videoRouter.js 생성하기



다음과 같은 파일들을 routers 폴더를 만들어서 안에 집어 넣기

<hr>

**userRouter.js 파일 코드**

import express from "express";



const userRouter = express.Router();



userRouter.get("/", (req, res) => {

 res.send("user index");

});



userRouter.get("/edit", (req, res) => {

 res.send("user edit");

});



userRouter.get("/password", (req, res) => {

 res.send("user password");

});



export default userRouter;

<hr>

**videoRouter.js 파일 코드**

import express from "express";

const videoRouter = express.Router();

export default videoRouter;

<hr>

app.js 파일에

import userRouter from "./routers/userRouter";

import videoRouter from "./routers/videoRouter";



app.use("/user",userRouter);

app.use("/video",videoRouter);

추가



이거 말고도 글로벌 라우터 하나를 더 가질껀데 그건 globalRouter

globalRouter는 /join , /login , /home 이런걸 다룰꺼임



왜냐면 아직 home URL이 없거든



routers 폴더에 globalRouter.js 파일 추가 



app.js 파일에

app.use("/",globalRouter); 추가

누군가 root("/")로 접속하면 globalRouter를 찾겠지?



/logout은 user에서 다뤄야겠지?



globalRouter에서 다뤄야 될껄 잘 생각해봐

/home

/join

/about_page

/search



userRouter에서 다뤄야 할껀?

/edit

/profile

/password



videoRouter 는?

/upload

/record





**이 방법이 유일하게 독점적으로 URL을 다루는 방법이다!!!!**

globalRouter.js / userRouter.js / videoRouter.js 여기에 있는 것들은 URL만 다루는 것들이기 때문에

우리가 앞으로 작성해야할 함수와는 아무 상관이 없다.

globalRouter에 /join은 말이 안돼... 이런거랑은 상관없써 단지 URL뿐임 controller가 아니야~



<hr>

import express from "express";

import corejs from "core-js";

import morgan from "morgan";

import helmet from "helmet";

import bodyParser from "body-parser";

import cookieParser from "cookie-parser";



import userRouter from "./routers/userRouter";

import videoRouter from "./routers/videoRouter";

import globalRouter from "./routers/globalRouter";



const app = express();



const handleHome = (req, res) => {

 res.send("여기는 홈 페이지 입니다.");

};



const handleProfile = (req, res) => {

 res.send("여기는 프로파일 페이지 입니다.");

};



app.use(cookieParser());

app.use(bodyParser.json());

app.use(bodyParser.urlencoded({ extended: true }));

app.use(helmet());

app.use(morgan("dev"));



app.get("/", handleHome);

app.get("/profile", handleProfile);



app.use("/user", userRouter);

app.use("/videos", videoRouter);

app.use("/", globalRouter);



export default app;

<hr>



routes.js 파일 만들어주기 (Divide and Conquer)



userRouter.js 파일에다가 /user/id/edit 이렇게 작성하지 않겠어

왜냐면 나중에 다른 곳에서 같은 URL을 사용해야 할 수도 있기 때문에..

ex) Redirect to /user/id/edit 이렇게 쓴다면 내가 다른 어딘가에 쓰고 싶을 때 이구조를 외우고 있어야 함



그래서 단 하나의 source를 쓰려고 함 그게 routes.js 파일임

그래서 이 파일안에 명시를 다 해놓고 언제든지 URL을 불러와서 쓰게 할 것임

//Global한 영역

const HOME = "/";

const JOIN = "/join";

const LOGIN = "/login";

const LOGOUT = "/logout";

const SEARCH = "/search";



//USERS

const USERS = "/users";

const USER_DETAIL = "/:id";   //내가 요청을 할 때 /users/1 이렇게 하면 1번 user를 주는 것

const EDIT_PROFILE  = "/edit-profile";

const CHANGE_PASSWORD = "/change-password";



//Videos

const VIDEOS = "/videos";

const UPLOAD="/upload";

const VIDEO_DETAIL = "/:id";

const EDIT_VIDEO = "/:id/edit";

const DELETE_VIDEO = "/:id/delete";



"/:id"이렇게 한 이유는 express가 똑똑해서 이런 형태의 URL을 보면 이 값은 변화하는 값이구나를 알아차림

콜론 없이 id라고 치면 그냥 text로 인식함



이제 아래에 object를 만들자



const routes = {

home: HOME,

join:JOIN,

login:LOGIN,

logout:LOGOUT,

search:SEARCH,

users:USERS,

userDetail:USER_DETAIL,

editProfile:EDIT_PROFILE,

changePassword:CHANGE_PASSWORD,

videos:VIDEOS,

upload:UPLOAD,

videoDetail:VIDEO_DETAIL,

editVideo:EDIT_VIDEO,

deleteVideo:DELETE_VIDEO

};

이렇게 작성하고 객체를 export 해주자



export default routes;



app.js 파일에서 import routes from "./routes"; 해주고



app.use("/",globalRouter) => app.use(routes.home,globalRouter);

app.use("/users",userlRouter) =>app.use(routes.users,userRouter);

app.use("/videos",videoRouter) =>app.use(routes.videos,videoRouter);

로 변경



globalRouter.js / userRouter.js / videoRouter.js  각각 import routes from "../routes"; 해주기



<hr>

globalRouter.get(routes.home, (req, res) => {

 res.send("Here is Home");

});



globalRouter.get(routes.join, (req, res) => {

 res.send("Here is join page");

});



globalRouter.get(routes.login, (req, res) => {

 res.send("Here is login page");

});



globalRouter.get(routes.logout, (req, res) => {

 res.send("Here is logout page");

});



globalRouter.get(routes.search, (req, res) => {

 res.send("Here is search page");

});



globalRouter.get(routes.about, (req, res) => {

 res.send("Here is about page!");

});



이런거 나머지(userRouter,videoRouter도 똑같이~

<hr>

이제  이 구조에서 벗어나기 위해서 controller를 써줄 것임



controllers라는 새 폴더 생성



videocontroller와 usercontroller를 만들 것임



대개 프로젝트에 있는 각 모델마다 컨트롤러를 만들게 된다.



이 프로젝트에서는 video, 비디오를 업로드할 users 그리고 routes를 한번 보자



const HOME = "/"  이걸보면 HOME화면에는 비디오들이 전달될거다.

나중에는 comment 기능도 만들것임(comment는 video controller에 넣을 것임)



컨트롤러는 어떤 일이 어떻게 발생하는지에 관한 로직!!!!

여기에 있는 모든 함수들이지!!! 여기 이 함수들을 모두 컨트롤러에 담을 것임

그 함수들이 뭐냐면 userRouter.get(routes.home,(req,res)=>{res.send("HOME")}); 요런것들



videoController.js 와 userController.js를 만들자 그리고 여기에 많은 함수들을 추가 할 것임



추가할 함수 각각을 export할 것임 예를 들어, globalRouter에서 이 Home함수는 videoController로 이동 시킬 것임.



videoController 파일안에 다음과 같이 작성



export const home=(req,res)=>{res.send("Home")}

export const search=(req,res)=>{res.send("Search")}





join,login,logout 관련 작업을 userController에서 해보자



export const join=(req,res)=>{res.send("Join")}

export const login=(req,res)=>{res.send("Login")}

export const logout=(req,res)=>{res.send("Logout")}





그 다음 globalRouter.js로 돌아가서 

import {home,search} from "../controllers/videoController"; 선언하고



다음과 같이 globalRouter.get(routes.home, home); 변경



이렇게 바꿔주는 이유는 전과 같이 쓰면 나중에 로직이 복잡해지면 더 어려워지기 때문에

controller로 분할 해주는 것임



다른것들도 똑같이 해주자~



### Recap

init.js에는 app.js에서 import 한 application이 있다.

application 관련 코드들은 app.js 파일에 담겨 있다.



express를 import했고, express를 실행한 결과를 app상수로 만들었다.

그리고 미들웨어 추가



cookieParser는 cookie를 전달받아서 사용할 수 있도록 하는 미들웨어

사용자 인증 같은 곳에서 쿠키를 검사할 때 사용해야 하기 때문!!!



bodyParser는 사용자가 웹사이트로 전달하는 정보들을 검사하는 미들웨어

요청 정보에서 form이나 json형태로 된 body를 검사한다.



이건 우리가 아바타의 사진이나 비디오를 업로드 할 때, 제목이나 댓글 같은 정보를 전달할 때 form에 담아서 업로드 해야 하기 때문!!



helmet 미들웨어는 application이 안전할 수 있도록 만들어준다.



moragan 미들웨어의 역할은 application에서 발생하는 모든 일들을 logging 하는 미들웨어



그리고 router 3개를 사용할 것임



첫 번째로 globalRouter인데 , 이 안에는 /home, /search, /join, /login, /logout URL이 담겨있다.

두 번째로 userRouter 안에는 /users/ 주소들이 담겨있다.

세 번째로 videoRouter 안에는 /videos/ 주소들이 담겨있다.



주소들은 routes.js에 정의해뒀다. 한 파일이 바뀌면 모두 적용되도록 할 수 있다.!!!!!



**모든 router의 로직들은 모두 userController나 videoController에 정의되어 있다.**

controller에 들어간 것들은 다 함수들이다 join,login,logout 등을 리턴하고 있다.



arrow function은 기본적으로 (req,res)=>{return res.send("join")}이다.



그 다음에는 Pug를 설치할꺼다

pug는 express에서 View를 다루는 방식 중 하나임!!!



express로 HTML을 보여 줄 수 있다. res.send대신에 실제 HTML을 전달할 것임



css같은 것들로 꾸밀 수 있고 pug가 View이다.



HTML을 아주 멋져 보이도록 만들어준다.





Pug(express의 view engine = template 언어) - express에서 View(데이터)를 다루는 방식 중 하나 - 웹클라이언트에게 HTML을 전달 가능 - HTML을 꾸며주기도 함 - app.set()(application 설정 함수)를 사용하여 view engine을 undefined에서 pug로 변경   - pug & express의 view 파일들 위치 경로를 바꾸려면 set 함수의 name으로 'views' 주면 됨   - default는 views 폴더이므로 우리는 views 폴더 생성     - home.pug 생성 - 문법   - p : html p태그 생성 - controller에서 send 대신 render( 문자열)



express에서 어플리케이션을 셋팅할때는 set()함수를 써야한다.

set함수에는 name과 value가 필요하다

어플리케이션의 설정을 하는 함수!!!

우리는 view engine의 설정을 바꿀것임 view engine의 default값은 undefined이기 때문에 pug로 바꿔줄것임



pug와 express에는 view 파일들의 위치에 관한 기본 설정이 있어

만약 그 설정을 바꾸고 싶다면 'views'설정을 바꾸면 됨

어플리케이션의 화면이 담긴 디렉토리나 디렉토리의 배열을 입력하면 된다네?



html파일을 저장해야 하는 폴더의 기본 값은 **프로젝트 작업 디렉토리 + /views**이다.



views라는 이름의 폴더를 생성하자



여기에 html 파일 하나 생성 

우리는 pug를 쓸 것이기 때문에 확장자 .pug 붙이기

home.pug



pug는 템플릿 언어이다. express의 view engine 임



그러면 이 템플릿을 웹사이트에 보여주려면 어떻게 해야 할까?



컨트롤러에서 res.send로 join을 전송하는 것 대신에 말이야



res.send 대신에 res.render 함수 쓰면 된다.



컨트롤러에 res.render("home")이라고 하면 

render함수가 views 폴더에서 파일명이 home이고 확장자가 pug인 파일을 찾은 후에 보여준다.



아까 기본 값이 "작업 디렉토리+views폴더" 였잖아?

그러니까 express는 자동으로 views 폴더를 찾아가는거지

내가 view engine 값을 pug로 설정해 놨으니까

그리고 render함수에 의해서 확장자가 pug이고 파일 이름이 "home"인걸 찾겠지?



이제 많은 템플릿 파일과 view를 작성하게 될것임



HTML,CSS에 대해서만 알고 있었지만 계속 header,footer 같은 부분을 복사-붙여넣기 해야 하기 때문에 못생겼을 거야



일단 함수별로 pug 템플릿 파일 만들기



HTML 과 CSS 만으로만 작업할 때는 똑같은 것을 반복하는 경우가 많기 때문에 별로 좋지 않다.



HTML과 CSS는 프로그래밍 언어가 아니기 때문에 논리적인 작업에 적합하지 않다

복사-붙여넣기 하는게 고통스러움



pug와 같은 것들로 작업을 하면, html을 생성하는 javascript의 위력을 사용할 수 있다.

아주 좋은 능력이지



views 폴더 아래 각 함수기능별로 pug파일 작성하고

layout 폴더를 views 폴더 안에 만들기

layout 폴더 안에 main.pug 만들기

main.pug는 모든 페이지들의 토대가 되는 파일



main.pug 에서 extension을 할 것임

main도 사용하고 거기에 추가적인 것을 더하겠다는 뜻



home.pug에

extends layouts/main.pug 라는 코드를 추가

그러면 이제 home화면이 layouts/main.pug 코드를 복사-붙여넣기 한다는 뜻



그러면 이제 block content가 들어가는 자리에 내용들을 채워넣을 수 있어





<hr>

### partials : 페이지의 일부분

**include ../partials/header**

**include ../partials/footer**

조직적인 목적으로만 만들어지지

views 폴더안에 partials 폴더 만들고 그 안에

header.pug, footer.pug라는 파일을 만들자



footer에는 아이콘이 들어갈꺼야



연도 불러오는 거

#{new Date().getFullYear()}



로그아웃 상태라면

헤더에 join, login 버튼이 보여야겠지?



로그인 상태라면

헤더에 upload, profile, logout 버튼이 보여야겠지?



우리가 추가한 라우트들이 pug파일로 연결되면 좋겠어



즉, routes.js에 있는 객체들이 pug파일에 연결되면 좋겠지?

URL을 쓸 수 있고 말야





### one single source of truth(한 곳에서만 정보를 보관)=> 더 나은 코드를 만들어주는 원칙





이제 템플릿에 정보를 추가할 시간!



컨트롤러에 있는 정보를 템플릿에 추가하는 방법을 알아보자



한 템플릿에만 추가하거나, 전체 템플릿에 추가할 수 있다.



템플릿 전체에 추가하는 방법부터 설명하겠다.

헤더가 라우트 객체 접근하고 싶어?

이때 미들웨어를 사용해야 한다.

미들웨어는 레이어 같은것!!!

위에서 밑으로 한단계식 내려간다.





처음에 view engine을 pug로 설정했어 => helmet이 있고 cookie를 파싱하고,body에 담긴 정보를 파싱해 => 그 다음에 morgan이 있고, 그 이후에 컨트롤러와 라우트들이 있지

이제 locals라는 미들웨어를 만들어 볼것임

local 변수를 global변수로 사용하도록 만들어주는 거라고 생각하면 됀다.

그래서 local기능을 통해 변수에 접근할 수 있다.



app.use((req,res,next)=>{

});



app.use(function(req,res,next){

});



const localsMiddleware = (req,res,next)=>{

}



위에 3개 똑같은거야



가장 깔끔해보이는걸로 쓰면 됨

나는 3번째껄 사용할꺼야

<hr>

const localsMiddleware = (req,res,next) =>{

}

app.use(localsMiddleware);

<hr>

Divide and Conquer를 위해서 미들웨어 파일을 하나 만들자

middlewares.js 파일 생성



여기에 locals를 추가 할 것이다.

locals가 추가되면 이제 그것들을 템플릿, 컨트롤러,어디에서든 쓸 수 있다.



app.use(미들웨어)를 쓸때는 위치가 중요하니까 신경 잘 써야 한다!!!



local변수에 접근하기 위해서 localsMiddleware를 사용할 것이다!!!



항상 알파벳 순서로 import하면 좋다~



export const localsMiddleware = (req,res,next) =>{

res.locals.siteName = "Working at Home"

}



locals에 있는 건 템플릿에 변수명 처럼 존재해



다른 locals도 추가해보자

routes에 routes.js 객체를 추가할거다

res.locals.routes = **routes;(routes.js파일 안에있는 routes 객체)** 



<hr>

import routes from "./routes"

export const localsMiddleware = (req,res,next) =>{

res.locals.siteName = "Working at Home";

res.locals.routes = routes;

next();

}

<hr>

미들웨어가 커넥션과 라우트들 사이에 있으니까 next()를 꼭 해주기



vscode에서는 pug 자동완성 기능을 지원해 주지 않는다.





자아 locals에 로컬 변수를 저장하면, 이 변수들을 템플릿에서 사용할 수 있다!!!

템플릿을 직접 수정하지 않고, middleware.js에서 수정을 하면 된다.



나중에 사용자 데이터 관련한 정보를 locals에 저장 해볼것임



지금까지 전역적으로 사용할 수 있는 변수를 추가하는 방법을 알아봤다.

모든 템플릿에서 사용할 수 있고, 템플릿,뷰,모든 곳에서 사용가능



이 멋진 locals라는 미들웨어는 코드 사이에 들어가 있어서, next를 호출해야 한다.

next()함수는 다음 함수로 넘어간다는 뜻 

우리의 경우에는 다음에 있는 라우터들로 넘어간다는 말



locals를 이용해서 전역 범위에 변수를 추가하는 방법을 배워봤다.





자 이제 한 템플릿에만 변수를 추가하려면 어떻게 해야 할까?

템플릿마다 다른 정보를 가질 수도 있을 테니까



어떤 템플릿에는 비디오, 다른 템플릿에는 사용자, 또 다른 템플릿에는 프로필~





render 함수의 첫 번째 인자는 템플릿 이름이고 두번째 인자는 추가할 정보가 담긴 객체이다!



res.render("home", {pageTitle : "Home"});

pageTitle의 값은 Home으로 하겠다.



pageTitle 값이 Home.pug템플릿으로 전달됨 전달된 값이 #{pageTitle}에 표시



home템플릿은 layouts/main 을 extend하고 있다.

home 템플릿은 이 템플릿처럼 보인다는 뜻이지

여기에는 pageTitle 변수가 표시될 자리가 있다.



{pageTitle : "Home", videos : 블라블라} 이렇게 video가 key인 정보를 추가해보자

템플릿은 그 정보를 보여주게 될 것임





header.pug에 다음과 같이 추가

header.header

​	.header_column

​		a(href)





컨트롤러를 시작하기 전에 페이지를 추가해보자

지금 상태는 페이지가 이쁘지 않다. 나중에 로직이 다 끝난 후에 프론트앤드 작업을 해서 이쁘게 바꿀 것임

작업이 섞이는 건 좋지 않다.



partials/header 파일을 조금 바꿔야 한다. 컬럼 하나 더 추가



form하나 action은 routes.search로 바꿔주기

그다음  method는 get으로. url에 있는 값들을 보고 싶거든!!!



input 태그의 name="term" 이렇게 설정하는 이유는 그 input태그 박스에 내가 데이터를 입력하면 그 데이터의 이름이 term이라고 url상에 표시가 될 수 있다.

![image-20200323170738155](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200323170738155.png)

여기까지 search페이지에 표시할 정보들이 주어졌다.

이제 search페이지를 수정해야 함



컨트롤러를 수정해서 #{searchingBy}에 값을 넣어 줄 수 있다.

globalController.js 파일의 search함수에 console.log(req); 쳐봐

거기서 query를 찾아! 내가 입력한 데이터를 볼 수 있음

그래서 console.log(req.query)를 치면 내가 친 데이터를 볼 수 있음



여기에 express가 query를 집어 넣는거야

이걸 통해서 많은 것들을 추가할 수 있다. &로 추가하면 됌



console.log(req.query.term)



const searchingBy = req.query.term은 ES6이전의 코딩방식 이걸 다시 아래와 같이 바꿀수 있다.



const {query} = req;   => req.query한 것과 같음



const {query:{term}} =req;   => req.query.term 과 같음



term에 이름을 할당 할 수도 있음



const {query:{term:searchingBy}} =req;

이 searchingBy를 search 템플릿에 전달할 수 있다.



입력값의 이름은 searchingBy, 실제 값도 searchingBy

<hr>

export const search = (req, res) => {

  const {

  query: { term: search_target }

 } = req;



 res.render("Search", { pageTitle: "SEARCH", searchingBy: search_target });

};



export const search = (req, res) => {

**const search_target = req.query.term;  //위의 const {query:{term:search_target}} =req;랑 같다.**

 res.render("Search", { pageTitle: "SEARCH", searchingBy: search_target });

};

<hr>



나중에 비디오 추가, 사용자 추가 같은걸 하면 로직이 더 추가되고 더 커질것이다.



mixins라는 걸 만들어 볼꺼다!!! 집중!!!



logout은 페이지가 아니다. 로그아웃 페이지는 없어

주소에 가면 로그아웃이 되고 다른 곳으로 redirect 돼야겠지?



USERS도 페이지가 아니다 USER_DETAIL은 페이지다.

videos도 페이지가 아니다 upload는 페이지



Home 화면 먼저 시작해보자



실제 mongodb 데이터베이스에 들어가기 전에 템플릿을 테스트할 수 있다.



그다음 login 화면





BEM을 사용할거야 기억나? 카카오톡에서 배운 BEM!!!

--





/users/edit-profile에 접속하면 /users/:id로 접속한 걸로 라우터가 이해를 해버렸다.

/usrs/edit-profile이 아니라





이제부터는 전체 애플리케이션의 흐름을 가짜로 한번 만들어 보겠다.

아직 데이터베이스를 이용해 실제 데이터를 넣기 전이니까



가짜 정보를 넣어서 템플릿을 완성할 것임(어떤 일이 어떻게 발생하는지 알기 위해)



그 이후에 데이터베이스를 이용해 실제 정보를 추가하고 사용자 인증 기능도 구현할 수 있을 것이다.



문제가 하나 있다.

routes.js에 있는 라우트들은 express와 잘 맞는다.

express는 /:id/edit-video 같은 것을 이해할 수 있지



문제는 뭐냐면 /videos/1/edit-video

여기 /:id 에는 url에 있는 값인 1이 실제로 들어가야해



어느하나는 express에 값을 전달하고 있고,

어느 하나는 브라우저에 바로 값을 전달하고 있다.



우선 home화면을 보자. 여기에서 video 목록을 보여줘야 해



mongoDB.js 파일 생성

html video mdn을 검색해서 보자 video 데모를 볼 수 있다.



creator도 추가하자 creator은 사용자임





videoControllers의 home에서 video 목록을 받아서 render함수에 전달하자



globalController.js파일의 home controller에서 home.pug 파일에 videos배열을 전달했어

이게 videos배열에서 하나씩 video를 처리하는 방식이야

<hr>

extends layouts/Main

block content

  .videos

​    h1 비디오

​    each item in videos

​      h1= item.title

​      p= item.description 

<hr>

item은 이름이 뭐든 상관없어. item키워드에는 목록의 아이템 하나하나가 들어있다. 여기서는 videos 배열에 있는 목록 하나하나가 아이템에 들어가 있겠지





웹사이트에서 계속 반복되는 코드를 복사-붙여넣기 하지 않고 재활용하는 방법을

mixin이라고 한다.

mixins 폴더를 만들어준다.

mixin은 웹사이트에서 자주 반복되는 html코드를 담고 있다.



mixin은 pug 함수의 일종이다.



mixin에는 인자가 하나 필요하다. 인자의 이름을 video라고 하고

기본 값은 {}로 하겠다. 기본적으로는 빈 객체이다.

mixin videoBlock(video = {})

객체가 mixin에 입력되면, 그 객체의 title을 받아와서 화면에 표시할 것임

each item in videos

​      h1= item.title

​      p= item.description



이걸 이렇게 써주지 않고

each item in videos

​	+videoBlock({

​		title:"Hello"

})

이렇게 써줄 것이다.

인자 객체 안에 title:"Hello"를 입력해보자



이 정보들이 videoBlock으로 전달되어서 mixin videoBlock(video = {})함수를 실행시킬 것이다. 그리고 이 함수는 html을 내보낸다.



각각 다른 정보를 가지지만 같은 구조를 가지는 데이터를 표시하기 위한 코드를

캡슐화해봤다.

이게 mixn을 사용하는 이유이다. **다른 데이터 같은구조!!!**





그 다음 search 화면을 작업할 거다 search도 home화면과 거의 비슷함











내일 애들이랑 같이 할 것

1.express 서버 구축

2.바벨 쓰는 법

3.router 설정

4.controller 설정

5.pug 쓰는 방법





### MongoDB

SQL / NoSQL



몽고 db는 더적은 규칙과 더 적은 절차로 작업이 가능한 데이터베이스





몽고db 파일 설치하고

터미널에 mongod 입력

그럼 작동

그리고 

mongo명령어를 치고 들어갈 수 있다.

exit하면 나갈 수 있고



mongo를 javascript와 연결해 보자

두가지가 있는데...



하나는 MongoDB이고 다른 하나는 Javascript의 NodeJS이다.



MongoDB는 C++이나 다른 걸로 만들어졌을 것이야

그리고 Adapter가 필요하다.



Javascript에서 MongoDB와 연결하려면 Adapter를 통해야 한다.

이걸 Mongoose라는 Adapter가 해 줄 것이다.



mongoose는 NodeJS를 위한 Object Modeling이다.



npm install mongoose



결국 database를 가지고 이용하려면

MongoDB 설치와

mongoose가 필요하다



정리해보자 MongoDB는 데이터베이스이고 이 데이터베이스와 javascript를 연결 시켜주려면 mongoose라는 어뎁터가 필요하다.

MongoDB는 NoSQL 데이터베이스이고 특징은 규칙이 적고 유연해서

많은 부분을 수정할 수 있다.



같은 서버에서 다양한 데이터베이스를 사용할 수 있다.!!!



첫번쨰로 Database에 관련된 걸 하고,

어떤 유저에게나 영상을 보고, 검색하고 수정하고 삭제할 수 있게 할 것이다.

영상 업로드도 물론이고 누구나 사용할 수 있는 플랫폼 같은거지



mongoose가 설치 됐고 'dotenv'라는 걸 설치할 것임

npm install dotenv



mongoDB.js파일에 다음과 같이 작성



import mongoose from "mongoose";



mongoose.connect("mongodb://localhost:27017/")   <= 여기서 우리한테 요청하는건 string으로 된 database이다.

어디에 database가 저장되어있는지 알려주는 역할

database의 URL을 적을 건데 그전에 mongo에서 포트번호 확인

mongoose.connect(**"mongodb://localhost:포트번호/Database이름"**

{

useNewUrlParser : true,

useFindAndModify : false

}

);



이렇게 적은 이유는, 새로운 버번의 mongoose는 이런 식으로 configuration을 보낼 수 있다.

내가 mongodb를 사용할 때마다 항상 '이봐, useNewUrlParser configuration을 추가해' '헤이 useFindAndModify configuration은 사용 안할께'

mongoose가 이야기 하는 것

새 버전은 이런건 가져가고 이런건 안가져가고



다음으로 할 건 mongoDB와의 연결을 'db'로 저장한 후

const db=mongoose.connection;



connectino을 열고 성공여부를 확인 할 수 있는 function을 만들게



import {videos} from "./mongoDB"는 database의 server.js으로 갈것이다.





dotenv를 설치한 이유는 가끔 내가 어떤 부분을 숨겨놓고 싶을 수 있기 때문

지금은 localhost에 설치한 MongoDB이지만 다른 곳에 설치 된다면 어떻게 될까?

네 코드에 있는 URL로부터 유저 데이터를 보는걸 원치 않겠지?



내가 open-source프로젝트를 하고 있다고 생각해봐

그런데 내가 database를 숨겨놓고 싶어



mongoDB.js 파일을 github에 올려놓으면 어디에 DB가 있는지 알게 될꺼야

지금은 localhost라 괜찮지만 보안상으로는 문제가 크다.

실제 어플리케이션으로 만들고 배포했을 때 문제가 된다.



 dotenv구성해보자



먼저 .env라는 파일을 생성하자

MONGO_URL이라는 variable을 만들어보자(우리의 URL을 넣을 것임)

MONGO_URL="mongodb://localhost:27017/working-at-home"

PORT=9000



import mongoose from "mongoose"

import dotenv from "dotenv"

dotenv.config();

그리고 dotenv.config 함수로 .env파일 안에 있는 정보를 불러올 수 있다.



mongoose.connect(process.env.MONGO_URL,

{

useNewUrlParser = true,

useFindAndModify = false

}

);



.gitignore에 .env 파일 추가해주기



server.js 의 PORT도 똑같이 해주기

이런식으로 key를 숨기는 것이다.

이렇게 하면 키가 다른 곳에서 보이지 않지



다음시간에는 Model을 만들것이다.



mongoDB의 장점은 document를 줄여준다는 것이다.



document가 뭔데? json 파일이라네?



하지만 mongoDB에 우리의 파일들이 어떻게 생겨먹었는지 알려줘야 함



좋아 몽고DB야 우리의 파일들은 video라는 이름을 가질 거야

그리고 모든 video들은 string type을 가질거고 그 string의 이름은 title일거야

video는 view를 가질거야

이런게 file의 형태, model의 형태이다.

이것들은 models라는 폴더에 저장될것임



models폴더 생성

그 안에 Video.js 파일 생성

import mongoose from "mongoose";



해야 할 것 하나는 model 즉 document name이고

다른하는 schema야 schema는 형태이다.



model은 그냥 실제 data이고



const VideoSchema = new mongoose.Schema({})

이건 이럴거고~ 저건 저럴거고 ~



우린 절대 Video를 Database에 저장하지 않을 것이다.

bytes를 저장하는게 아니라 Video의 link를 집어 넣을 것이다.



우리의 경우에 우리 서버(Amazon)에 Video를 저장하는 것이지

Database에 Video를 저장하지 않아

이건 그냥 text Database이다.



Video의 주소를 넣는것

Video 전체를 넣는 게 아닌거다!!!

왜냐하면 비디오 전체를 넣으면 database가 너무 무거워 지기 때문...



File_URL 값이 없는 Video를 생성하려 한다면 이 error message를 받겠지?





Date.now 자체는 function이고

Date.now()는 그 함수를 실행해서 현재 남짜를 반환하는 것임



내가 할 수 있는 게 뭐가 있는지 알고 싶다면 

**mongoose documentation의 schema section에서 모든 option들을 확인 할 수 있다.**



이제 이 schema를 이용해서 model을 만들어보자

definition을 통해 실제 document를 만드는 거지

schema가 definition 같은 거다.



const model = mongoose.model("Video",VideoSchema)

그리고 Video model의 Schema는 VideoSchema가 될 것이다.

맨위에 있는 const VideoSchema = new mongoose.Schema



그리고 export default model



현재 우리 Database는 아직 인지 못하고 있어

아직 이걸 생성했다는 것을 모르는 거지



연결은 되어있지만 거기에 model이 있다는 건 알지 못한다.

그래서 추가를 해줘야 함



그래서 server.js 파일에서 import를 해준다.

import "./models/Video";



이제까지 Video model이었다.



다음은 video comment를 만들 것이다.



Comment Model 만들기



comment에는 text가 있어야겠지



근데,

description:String,

views:{

type:Number,

default:0

}



네가 무언가 줄 옵션이 있다면 객체로 만들어야 해

그렇지 않으면 그냥 한 줄이면 된다.



default를 추가하거나 required를 추가하는건 configuration object이다.

configuration이 



comment에 video의 ID를 저장하거나

video가 ID의 array를 가지고 있는거지



어떤게 어떤 것과 연결되어 있는 지 알아야 하거든...

video에 comment를 달 때 comment를 단 비디오와 직접적으로 연결 되어 있는지?



모든 객체들은 보통 ID를 가지고 있다.

우리의 이름 처럼 말이야

따라서 모든 comment의 정보를 저장하는 대신



모든 video들이 comment id들을 가지고 있는 거지



처음 video를 생성하면 comments는 0일 것임 왜냐? 당연히 comment가 처음에는 없으니까 그리고 comment를 달면 새로운 comment ID를 video안에 있는 comment의 list라는 곳에 저장



따라서, 이 comment는 이 video와 연결되어 있고

이 video의 type은 mongoose.Schema.Types.ObjectId

video:{

type:mongoose.Schema.Types.ObjectId

ref:"Video"

}

어떤 object ID가 어디서 온건지를 알려줘야겠지. 어느 Model에서 온건지

ref:"Video"

실제로 우리는 Video의 ID를 원하거든



좋아요를 저장하거나 유저를 저장하거나 할 땐 다른 ref를 사용하겠지?



이게 방법 첫번째

comment를 생성하면 text와 CreatedAt을 생성하고 video ID는 1



다른방법도 해보자

<hr>

이번에는 Object ID들의 array를 생성해야 한다.

모든 comment ID들을 array로 video로 집어 넣을 것인가


혹은 Comment에 연결 된 Video ID를 줄 것인가

<hr>



type:mongoose.Schema.Types.ObjectId

위 코드에서 ObjectId는 모든 comment의 정보를 넣는게 아니라 Comment의 ID만 넣는 것이다.





이렇게 만든 Model들을 어떻게 사용할 수 있을까???

videoController에서

누군가 home으로 가면 여기 videos는 undefined일 거야



여기에 새로운 Javascript 요소인 async라는 걸 추가 할 것이다.

async는 나를 기다려주는 무언가임



Javascript는 기본적으로 나를 기다리게 프로그래밍 되어있지 않다. 비동기적임



export const Home = (req,res)=>{

res.render("Home",{pageTitle:"HOME",videos:videos})

}

위와 같은 코드를 보면 javascript는 videos를 보기는하지만 끝나기를 기다리지는 않는다.

다음으로 넘어가서 Video가 없는 페이지를 render하지. 

아직 Video를 살펴보지 못 했기 때문에



자바스크립트는 한번에 많은 일을 할 수 있다.

일단 video를 살펴보고 있으니까 다음 render작업도 같이 할께~



그래서 우리는 자바스크립트가 우릴 기다리게 해야 한다.

그렇게 하려면 async라는 keyword를 추가해야함



자바스크립트야 이 함수의 어떤 부분은 꼭 기다려야 해!!!라고 이야기하는 것과 같다.



const videos = await Video.find({});

awit는 다음 과정이 끝날 때까지 잠시 기다려 달라는 의미

위와같이 작상하면 Database에 있는 모든 Video를 가져올 것임

과정이 끝나면 videos가 정해질 것이고 그 videos는 여기에 쓰일거다

export const Home = async( req,res)=>{

const videos = await Video.find({});

console.log(videos);

res.render("Home",{pageTitle:"HOME",videos:videos});

}



async를 쓰지 않는다면 error가 난다.

await keyword는 async 없이는 쓸 수가 없다.

위와 같이 코드를 작성하면 await부분이 끝나기 전까지는 render 부분을 실행하지 않을 것이란 걸 확실하게 보여준다.



try   / catch 구문을 써주자

error가 생기면 video는 없을 것이고

default로 videos는 빈 array가 되겠지?

export const Home = async(req,res)=>{

try{

const videos = await Video.find({});

}catch(error){

console.log(error);

res.render("Home",{pageTitle:"HOME",videos:videos})

}

};



우리가 upload버튼을 누르면 Video가 아닌 다른 file이 upload 되는걸 원하지 않는다.

file을 Upload해서 middleware에서 받아





그리고 그 middleware에서 file을 upload하고 URL을 복사해서 Database에 저장하는 것



내가 업로드할 때 원하는건 location이야 어떤 서버에 있는 location

내 서버일 수도 있고 , 아마존 서버일 수도 있다.

이건 엄청 중요하다!!!!

난 file 자체를 저장하지 않을꺼야!!! 데이터베이스가 무거워지니까

file의 location을 저장하는 거지!



accept = "video/*"



파일을 upload하고 URL을 반환하는 middleware가 있어야한다.

이 미들웨어의 이름을 multer라고 한다.



내가 function을 집어 넣으면 multer라는 미들웨어가 file의 URL을 반환할것임

npm install multer



그리고 우리의 upload form의 enctype에 multipart/form-data를 추가해야 함

왜냐하면 우리는 file을 보내는 것이기 때문에

form의 encoding이 달라야 한다네?



이제 middleware.js에서 multer로 미들웨어를 만들어보자

configure 과정은 엄청 쉽다는데..?



middlewares.js 파일에서

import multer from "multer"



export const uploadVideo = multer({dest:"videos/"})



우리가 제대로 했다면 파일을 upload하면 server에 있는 folder(video/)에 upload

postUpload라는 함수는 해당 file에 접근할 것이다.



file방식이 아닌 URL 방식으로 말이야











db.videos.remove({})





express에서는 모든 것에 대한 route가 있다.

uploads를 위한 기본적 route가 필요해



내가 /uploads 요청을 한다면 express.static()을 통해서 찾아갈것임

express.static은 디렉터리에서 파일을 보내주는 미들웨어이다.

app.use("/uploads",express.static("uploads"));

/uploads로 가면 uploads라는 디렉터리 안으로 들어간다는 거지



get은 뭔가를 채워넣는 작업이고

post는 업데이트하고 redirect하는 작업이다.







href=routes.deleteVideo(video.id)

비디오의 id와 함께 함수를 실행할거야

기억해 우리는 비디오의 Object를 가지고 있다.

왜냐면 우리가 템플릿에서 전달했거든! videoController.js의

res.render("editVideo",{pagetTitle:`Edit ${video.title}`})







이제 비디오 삭제 작업을 할 것이다.

deleteVideo는 string을 return하는 function이다.

먼저 videoRouter.js에서 



videoRouter.get(routes.deleteVideo(),deleteVideo);

deleteVideo()는 string을 return하는 함수이다.



그리고 videoController.js에 가서 deleteVideo 함수 고쳐주기

먼저, 파라미터를 받아보자



const {

params:{id}

} =req;



async 하는 것도 잊지말고!



그 다음 try/catch 해주고~



export const deleteVideo = (req,res)=>{

const {

params:{id}

}=req;

try{

await Video.findOneAndRemove({_id:id});

res.redirect(routes.home);

}catch(error){

res.redirect(routes.home);

}

}





이제 search작업을 할 것임

실제 Database로 검색은 아직 안해 봤다.



일단 비디오 업로드 해놓은 후에~



새로운 비디오가 먼저 나오게 바꾸기!

그러려면 모든 비디오를 찾고 정렬을 해야 한다.

const videos = await Video.find({}).sort('_id:-1')

값을 -1로 주는 이유는 위 아래 순서를 바꾸겠다는 약속같은것

_id 값으로 정렬을 한거고 무엇이든지 원하는 것으로 정렬을 할 수 있다.

제목으로도~



search탭에서 검색하고 싶은 비디오 파일 이름을 검색하면 아직은 찾아 올수가 없음

왜냐? search.pug에는 video리스트들을 가지고 있지만

globalController.js의 search 함수의 동작을 어떻게 할껀지 정의 하지 않았기 때문!



이제 ESLint라는 걸 이용해 볼것임



여기 나는 videos라는 variable 이름을 가지고 있지만 videos는 variable나 global로 존재 하지 않는다.



자바스크립트가 나에게 지금 서버를 돌리는 건 영 좋지 않은 것 같은데라고 말하고 있음

왜냐면, 해당 에러를 사용자가 보고 '뭐시여 이게'라고 해야 에러의 존재를 알 수 있기때문



이때 자동적으로 나를 도와주는 녀석이 Linter

Linter는 뭔가 틀린게 있으면 알려주는 친구임

"이거 틀렸어"

"이러면 안돼는데"

"이 코드가 좋고 이 코드는 구려"



npm install eslint (ESLint 절대로 global하게 설치하지 마~)



npm은 패키지를 설치하는 거야, 폴더에 있는 node_modules에 말이지



그런데 때때로 내가 그냥 package를 내 컴퓨터의 아무데서나 사용하고 싶을 수도 있겠지?



만약 내가 ESLint를 global 하게 설치했다면 모든 프로젝트에서 사용 가능하고

같은 파일의 복사본을 계속 설치할 필요가 없다.



설치를 끝내면 다음과 같이  입력

eslint --init

그 다음에는 ESLint를 어떻게 설정하시겠습니까 질문창이 뜸



3가지 옵션이 뜸

1. 내 자바스크립트 파일을 조사하기
2. 질문에 답하기
3. 가장 많이 쓰는 스타일(이거 선택)



스타일 가이드도 있음

1.에어비앤비(이거 선택)

2.기본



리엑트 사용할꺼냐고 하면 안사용한다고 체크



어떤 파일 포멧을 config파일로 하고 싶나요? Javascript



그 다음 대답은 yes



마치고 나면 ESLint plug-in 들이 설치가 진행이 됨



당신의 global한 설치본 대신에 local한 설치본을 사용하십시오!



ESLint가 모든 에러를 알려주고 있어

몇몇 에러는 스타일에 관한 것임



ESLint 확장프로그램 마켓 플레이스에서 설치해주기



여러가지 에러가 뜨는 걸 볼 수 있음

string은 작은 따옴표로 묶어야 한다.



그리고 포멧에 맞춰서 이쁘게 만들어주는건

Prettier라는 plug-in을 사용해서 그런것임



일단 ESLint에게 내 코드의 구조가 이렇다는 코딩 스타일은 조용해줬으면 좋겠으니까

설정을 따로 해줬으면 좋겠음

"plugin:prettier/recommended"

다른 오타라던지 이상하게 표현을 한건 표시해주면 고마운건 맞지만!



npm install eslint-config-prettier -D

npm install eslint-plugin-prettier -D

npm install prettier -D





userController의

name, email에 값이 주어졌지만 사용되지 않음

name을 정의했지만 그 값이 읽히지 않았다는 거제





정규표현식이라는게 있음



정규표현식은 string으로 부터 무언가를 가져오는거야

hello lalalalal 

멋진 정규표현식들이 많다.



정규표현식에 텍스트를 넣으면

예를 들어 handsome을 정규 표현식에 넣어주고

Test String에 

hello lalal handsome 에서 handsome만 표시해줌



우리는 MongoDB가 handsome이나 Handsome을 찾게 해야 한다는 것



let videos = [];

const videos = [];



let은 한번 빡에 사용하지 않았다고?

값을 바꾸지 않으려면 const를 사용해야 한다.



난 나중에 비디오를 찾으면 값을 바꿀 것임



어떤 제목을 가지고 싶은 영상을 찾고 싶은데



videos = await Video.find({title:{$regex:searchingBy, $options:"i"}})

{$regex:} 이게 정규식표현 그냥 find를 이용해서 제목을 찾지말고

정규식 표현을 이용해서 제목을 찾아!

그리고 옵션을 추가 할 것임

나는 대소문자를 구별하지 않을 것임

"i"는 insensitive 덜 민감하다는 걸 의미한다.(대소문자를 구분하지 않음)



여기 빈 배열의 videos를 만들었고 어떤 videos도 찾지 못한다면

빈 배열로 render 될 것이고



비디오를 찾는 다면 videos가 reassign되는 거지

그래서 const를 쓰지 않은거임

내가 찾은 videos로 reassign 할 것이기 때문에





## 프론트엔드 부분

webpack은 모듈 번들러임

우리가 많은 파일들을 가져와서 webpack에게 주면

webpack은 그것들을 완전히 호환이 되는 static파일들로 변화해서 주는 것



sass는 말하자면 섹시한 CSS임



우리는 모던 자바스크립트를 webpack안에 집어 넣고

그걸 받은 webpack은 그냥 일반적인 css와 오래되고 노멀한 자바스크립트로 변환해서 브라우저가 알아먹을 수 있게 해줄꺼야!!!



결국, 빠르게 발전하고 있는 자바스크립트 문법과 스타일링을 브라우저가 그때그때 따라가기는 힘들기 때문에 webpack이라는 모듈 번들러를 사용해서 브라우저와 호환이 되는 파일들로 바꿔준다는 말!!!



npm install webpack 그리고 webpack-cli (터미널에서 webpack을 쓸 수 있게 해줌)



webpack.config.js 파일 생성



이제 실행시킬 때 npm start 안시킬꺼야



"start" = > "dev:server"

"dev:assets" 추가



이젠 npm run dev:server 그리고 npm run dev:assets로 

각자 다른 콘솔에서 실행시켜야 해



그리고 누군가 dev:assets라고 치면 webpack을 불러오도록 해놓을 것임



결국, npm run dev:assets 은 webpack을 불러오도록 하는것임

"dev:assets" : "webpack"    => 이것은 자동으로 webpack.config.js 라는 파일을 찾으려고 할꺼야!!!! 파일 이름 바꾸면 안됌, 파일 이름을 바꾸고 싶다면 바뀐 이름을 알려줘야 한다.

--config 플래그 써서!!!





기본적인 규칙은, webpack은 exported configuration object를 찾는다는 것



이 config 파일 안에서 명심해야 될 건, server 코드와는 연관시키지 않는다는 점이다.

webpack.config.js 는 100% 클라이언트 code이다!!!!!!!!!!!!!!!!!!!!!



즉,우리가 앞에서 예쁜 코드를 작성할 수 있도록 넣어준 babel-node는 쓸 수가 없음

그래서 우린 webpack.config.js 파일 안에서는 옛날 자바스크립트를 써야 함



옛날 자바스크립트 export는 이렇게 쓴다

최신 꺼 : export default "객체"

옛날 꺼 : module.exports = config;



webpack.config.js 파일 안에 다음과 같이 작성



const config = {



};



module.exports = config;



webpack은 두가지를 가지고 있다.

하나는 entry라고 불리는 것이고, 다른 하나는 output이라는 것이다.



entry는 파일이 어디에서 왔는가?이고

output은 그걸 어디에 넣을 것인가? 를 의미한다.



우리 실습에서는, assets라는 폴더를 생성할 것이다.



assets 폴더안에 js 폴더랑 scss 폴더 생성

js폴더 안에는 main.js 파일 생성

scss 폴더 안에는 style.scss 파일 생성



main.js에서는 모던 자바스크립트 문법을 써서, import를 해줄 것이다.



background-color : aqua



webpack.config.js 파일에서 2개의 const를 만들 건데



const Entry_File = 

const Output_Dir =



NodeJS에서는 파일과 디렉토리(경로)를 절대적으로(absolute)로 만들어주는 방법이 있다.

다시 말해서, 컴퓨터나 서버에서의 전체 경로를 갖게 되는 것이다.

path라는 걸로 할 수 있다.



path는 Node.js에 기본으로 깔려있는 패키지이다.



쓸때는 2가지방법으로 쓸 수 있다.

const path = require("path");   //옛날 자바스크립트

import path from "path"; 	//모던 자바스크립트



webpack.config.js 파일은 옛날 자바스크립트 문법을 써줘야 함





const Entry_File = path.resolve(__dirname,"assets","js","main.js");

"__dirname"은 현재의 프로젝트 디렉토리 이름인데, 이건 어디에서든 접근 가능한 NodeJS 전역 변수이다. 



Output_Dir은 디렉토리이니까 path.join을 쓴다. 파일이 아니기 때문에

static이라는 폴더로 보내라(export) 할거야



const config = {

entry : Entry_File,

output :{

path:Output_Dir,

filename:"[name].[format]"   => "[name].js"

}

}



ouput은 object여야 한다.



우리는 앞으로 사용할 모든 파일의 형식들을 webpack에게 가르쳐줘야한다.



만약 png파일을 쓰고 싶다면, webpack한테 어이! 이건 png라는 건데 변환은 이렇게 하는거야 뭐 이렇게!!!!



"dev:assets" : "WEBPACK_ENV = development webpack"

저기서 WEBPACK_ENV= development는 mode를 설정해주기 위해서 .env파일 뭐시기뭐시기



npm install cross-env 설치



네가 확장자가 .scss인 파일을 만날 때마다 어떤 loader를 실행하거라



loader란건 기본적으로 , webpack에게 파일을 처리하는 방법을 알려주는 역할을 한다.



webpack은 아무것도 몰라

loader를 추가해줘야 얘가 비로소 파일 다루는 법을 알게 되는 것이지



이 경우에는, 먼저 상태를 시험해볼꺼야



"좋아,파일을 만나면, 그파일이 scss인지 알아봐"라고 시키는 것이지

test할때는 정규식 표현을 써야한다.



내가 얘기하고 있는 건 , 원하는 부분(즉, 여기서는 css부분)의 텍스트만 뽑아서 파일을 쓰기 위한 것이다.



문자열이 아니다. 정규식이니까 따옴표로 시작하진 않고~

/\ 로 시작한다. 그다음은

/\ (.scss)



끝마칠때는

/\ .(scss)$/         <= 그러면 얘는 scss인 파일을 전부 찾아줄것임



/\ (.scss|sass)$/     <= 확장자가 scss와 sass 파일을 찾게 해줌



우리가 scss파일을 찾았을 때는 가장 먼저 그 scss를 css로 바꾸고

그 css에 해당하는 텍스트 전체를 취해서

즉, 그 텍스트를 추출해서 css파일로 저장해야 되는것임



**처음에는 확장자가 scss인 파일을 찾고, scss를 css로 바꾸고 전체 텍스트 중에 그 css의 텍스트를 추출하고 그 추출된 css를 분리된 하나의 파일로 만드는거야!!!**





이건 왜 그런거냐면, production을 만들 때 내 코드는 압축되거든

개발하는 중에는 코드가  압축되지 않지. 에러가 발생했을 때 어디에서 일어난 건지 볼 수 있어야 하니까



수동으로 .env파일에 설정했던 것 같이 설정변수 수동으로 해주는 방법

WEBPACK_ENV=development  => mode 설정해 주고 싶어서

"build:assets" : "WEBPACK_ENV=production" => 이건 내 코드를 server에 올려줄꺼야

그리고 webpack.config.js 파일로 와서 그 ENV를 받도록 할 것임



const MODE = process.env.WEBPACK_ENV;



아직 css를 webpack이 이해를 하지 못하니까 rules를 추가 할 것이다.

rules는 array이다. config라는 object안에 있는 array



내가 확장자 scss 파일을 만날 때마다, 어떤 loader를 실행하거라

loader란 건 기본적으로, webpack에게 파일을 처리하는 방법을 알려주는 역할을 한다.

webpack은 기본적으로 처음에는 아무것도 할 수 없기 때문에 

loader를 추가해줘야 얘가 비로소 파일 다루는 법을 알게 되는 것이지



npm install extract-text-webpack-plugin을 해줄 껀데 뒤에 조건을 붙여줄것임

가끔, 어떤 라이브러디르은 더이상 사용되지 않을 예정인(deprecated)경우가 있다.

그래서 개발자들이 이제 이건 더이상 쓰지 않으니까 쓰지마 블라블라



그래서 npm에서는 새로운 버전을 설치하고 싶을때마다 @기호를 쓰는 방법이 있다.

@을 쓰면 구체적으로 어느 버전을 설치할 건지 명시해줄 수 있거든!

@2.3이라고 해주면 정확히 버전 2.3을 설치할 수 있지



@next를 넣어서 설치해줄 것임

그러면 베타버전으로 설치가 진행이 될텐데

베타버전은 정식버전으로 공개가 되지 않은 버전



설치가 완료되면 가져다가 써야겠지?

const ExtractCSS= require("extract-text-webpack-plugin")



use:ExtractCSS.extract()

먼저 scss파일을 css로 바꾸는 게 선행되어야 하는데



먼저~

1.나한테 sass파일이 있고

2.sass파일을 가져와서 css파일로 바꾸고

3.그 css에서 ,webpack에게 css를 어떻게 다루는지를 알려주면 그제서야 녀석을 추출할 수 있다.





webpack에선 사실, (loader를 사용할 때) 끝에서부터 시작해서 처음으로 진행한다.



예를들어 이 경우에는, 여기 적힌 대로라면,

extraction부터 먼저 할 것만 같지.

보통은 제일 위에서부터 시작하니까



근데 webpack은 webpack.config.js파일에서 아래에서 위로 실행한다!



그래서, 여기에 쓸 때는 먼저 extract하는 것부터 써야 하고

다음에 css파일을 이해시키는 부분을 적어야하고 그 다음에 sass파일을 다루는 부분을 적어야 한다.



즉, 코딩순서가

1.extract 시키고

2.css파일 이해시키고

3.sass 파일다루는 부분을 적어야 함



webpack이 이걸 실행하면, (작성할 때와는 반대 순서로)

먼저 scss파일 다루는 것부터 하고, 다음엔 css파일 다루고 그 다음에 추출을 진행함



use:ExtractCSS.extract(

[

{

loader:"css-loader"

},

{

loader:"sass-loader"

}

]

)

이 로더는 webpack이 css를 이해할 수 있도록 가르쳐줄꺼야

아 맞다. 이건 array야

왜냐면 여기에 많은 loader가 들어갈 수 있거든



여기서 문제가 있어 우리는 sass파일을 호환시키려고 하는건데

우리는 코드를 그냥 번역만 할 게 아니라 여기에 호환성을 부여하고 싶은 것이지

그러므로, 여기에 loader 하나를 더 추가해줘야 한다.

{

loader:"postcss

}



module를 발견할 때마다 다음과 같은 rules를 따르라고 하고 있다.

먼저, 어떤 조건(condition)을 알아보라(test)고 할 것이다.

scss로 끝나는 어떤 module(이 경우엔 styles.scss파일)을 만나게 되면, 이 plugin을(Extract.extract()) 사용하도록 하고 있다. 



그리고 이 plugin은, 내부에서 또 plugin을 사용하고 있다. 왜냐하면 scss파일을 일반적인 css로 통역해야 하거든!!!!

그걸 위해 sass-loader를 사용한다. sass-loader는 sass혹은 scss를 받아서 일반 css로 바꿔줄 수 있다.

그런 다음 postcss-loader를 사용할 껀데 얘는 css를 받아서 우리가 얘한테 주는 plugin을 가지고 css를 변환해줄 것임 ex)우리 코드,우리 css를 예로 들어보자 이걸 웹 브라우저와 호환되게 만들자! 라고 할 수 있겠지? 그럼 이 postcss-loader가 다 알아서 해준다.

prefix(접두사)부터 잡다한 것들까지 처리해주는 것이지



그다음 css-loader를 이용하면, webpack이 css를 이해할 수 있게 되는거다



npm install css-loader postcss-loader sass-loader 

npm install node-sass

나중에 내가 작성하는 최신 자바스크립트 문법(babel)을 webpack이 이해 할 수 있게끔 하는 loader도 설치해야함 npm install babel-loader



postcss를 통해서 Autoprefixer라는 걸 사용하면

이 속성(property)는 webkit을 쓰는 브라우저에서 지원하지 않으니까, 이렇게 추가 시켜줄 거야

npm install autoprefixer



postcss-loader 안에 options 넣어주고

이제 plugin이라고 적을 건데 이 plugins는 함수(function)가 될 것이고

이 함수가 리턴하는 것은plugin들로 구성된 array이다.(이 케이스에는 plugin이 하나만 있지, 우리는 지금 하나의 plugin으로만 이루어진 array를 리턴해주고 있지. 원하는 만큼 많은 plugin들을 추가해 줄 수 있다.)

먼저 import 부터 해야 한다.



const autoprefixer =require('autoprefixer')





sass-loader는 sass를 css로 옮겨주고,

postcss-loader는 특정 plugin들을 css에 대해 실행시켜주고

css-loader는 css를 가져와주고

ExtractCSS로 그 부분만 추출해주는 것





스크립트를 2개 만들어야 한다.



하나는 dev하는 것 "dev:assets": "WEBPACK_ENV=development webpack"

다른 하나는 build를 하는 것이고 "build:assets" : "WEBPACK_ENV=production webpack"



둘은 차이가 있는데, 일단 dev:assets는 파일들을 지켜보도록 할 것임 -w 추가

왜냐하면, css파일을 수정할 때마다 webpack을 끄고 다시 실행시켜주고, 그런 귀찮은 짓은 하고 싶지 않거든

즉, -w를 해줌으로써 파일들을 지켜보고 있다가, 만약 변화가 생기면 자동으로 webpack을 다시 실행시켜줄것임 



그리고 views폴더안의 Main.pug로 가서 css스타일 적용시킬 수 있게 link해주기

link(rel="stylesheet",href="/static/styles.css")



그리고 Main.pug의 footer 밑에 <script> 작성해주기

script(src="/static/main.js")



문제는 내 서버에는 아직 이걸 알려주지 않았다는 것!!!!



그래서 서버에 알려주기 위해서 app.js 파일에서 upload 파일을 알려줬었던 것처럼

route처리를 해줘야 한다. static route를  추가해줘야 함



/static이라는 이름의 route는 지금 존재하지 않기 때문에 추가해야 되는 것임



누군가 /static 으로 가려고 하면, 난 static폴더로 가보라고 할 것이야~





자 기억해보자

1.entry가 있고

2.mode(development 또는 production)가 있고

3.rules가 있고 각종 loader들이 있지





@babel/polyfil은 기본적으로 "충전솜" 브라우저에 아직 없는 무언가를 보유하고 있는 것?

그러니까, 브라우저의 구멍을 메워주는 자바스크립트 파일 같은 것!





webpack의 설정(config)에 변화를 주면 다시 껐다가 다시 켜야 빌드시켜줘야 한다.

npm run dev:assets