## 재택근무 관리 시스템(3차 프로젝트/4인팀플)

프론트앤드 : pug

백앤드 : NodeJS

DB : MongoDB

빌드 시스템 : webpack



NodeJS : 브라우저 밖의 자바스크립트(사용자가 브라우저 밖에서도 자바스크립트를 이용해 서버를 만들 수 있고 파일 시스템과 연동할 수 있다.) 원래 자바스크립트는 브라우저에 종속되어 있었는데 그것을 극복 할 수 있게 도와준게 NodeJS이다.

**NodeJS를 사용하는 이유**

1.프론트 앤드와 백앤드 둘다 자바스크립트를 사용하고 싶어서

2.내가 기본적인게 셋팅되어 있지 않고 커스터마이징 하고 싶을 때는 자바스크립트가 (Django/Python),(lalabel/PHP)보다 좋다. 작은 블록을 쌓아서 큰 성을 짓는다고 생각하면 됨

3.내가 많은 데이터를 움직여야 할때 좋다.(Database 생성,삭제)/ 엄청 많은 사람들이 데이터를 보내고 받고/알림/ 실시간 등을 처리할 때는 NodeJS가 좋은 퍼포먼스를 보여줄 수 있다.(내가 데이터를 다뤄야 할 때)



자, 서버란 무엇일까?

서버란 컴퓨터(인터넷에 연결된 컴퓨터)

소프트웨어적인 서버는 뭐야? 인터넷(네트워크)에 연결된 한 덩어리의 코드이다.

URL에 응답하고 접속을 허락하는 일을 한다.



내가 URL을 통해 페이지를 요청하면 어딘가에 있을 서버에 저장된 데이터가 나에게 보내진다.



정리하자면 기본적으로 서버는 2가지로 나눌 수 있다.

1.물리적으로 늘 켜져있는 컴퓨터

2.인터넷에 연결돼 있고 내 접속 요청에 응답하는 컴퓨터

프라이빗한 서버를 집에 직접 놔둘 수 있겠지?

서버란 접속을 받아주는 무언가라고 할 수 있겠지?

어떤 접속을 듣고 있는 무언가지



**Express란 무엇일까?**

익스프레스는 프레임워크라고 할 수 있다.

이미 많은 사람들이 우리를 위해 훌륭한 기능들을 만들어놔서 우리가 그걸 가져다 쓰면 됨

이때 NodeJS로 서버를 만들 수 있게 도와주는 프레임워크가 Express라고 할 수 있다.

Express를 이용해서 단 몇 줄의 코드로 서버를 만들 수 있다.



이미 많은 프레임 워크들이 있어~ 예를들어 Django는 Python에서 작동하는 프레임워크라고 할 수 있지

Rails는 Ruby로 된 프레임워크, Larabel은 PHP로 된 프레임워크

이것들 모두가 유저들의 개발을 도와주는 프레임워크라고 할 수 있다.



NodeJS위에서 작동하는 Express는 안정적이기 때문에 많은 사람들이 쓰고 있다.



### 본격적으로 Start

1.nodeJS 다운받기

node -v

2.npm 설치(세상에 좋은 사람들이 express 같은걸 만들었어 그러면 이런걸 공유하게 싶겠지? 그런데 기존의 방식은 우리가 다운로드 받으로 사이트를 들어가야 하고 기다려야 하고 이런 작업들을 하기 싫은거야 그래서 npm이나 yarn이 나온것)

NodeJS 진영의 중심이 npm이라고 할 수 있지. 그 진영에 들어가서 필요한 패키지를 다운로드 받는 것 그 패키지에는 express,react,react-native 같은 것들이 있는 것임

자바스크립트로 프론트앤드, 백앤드를 만드는 각자의 패키지를 담아서 올리는 곳

그래서 우리가 다운로드 받고 업데이트 하고



npm -v

NodeJS를 다운로드 받으면 npm은 자동으로 설치가 이루어짐(패키지를 자동으로 공유하고 받을 수 있어야 하니까!)



npm이 정한 방식으로 프로젝트를 시작하는 거지

1.npm init을 치면 패키지의 이름 등을 작성하라고 하지? 이제 내가 패키지를 구성함으로써 웹사이트를 만드는거야 오케이?

package.json은 javascript에서 정보를 담는 방식이다.

npm install express할때 꼭 package.json이 있는 폴더 내에서 설치를 하자

express도 다른 것들에 의존하고 있다. 그래서 50개의 패키지를 같이 가져오는 것

설치를하고 node_modules를 지워도 package.json에 이미 express가 명시되어 있기 때문에

다시 npm install만 해도 package.json에 명시되어 있는 의존성 dependencies를 설치하게 된다.



package-lock.json 파일은 package.json의 보안에 관련된 사항을 명시해주고 있음 그래서 이것도

.gitignore에 명시해주는게 좋음

<hr>

const express = require("express"); //express 모듈파일을 블러온다. express 모듈파일은 또 다른 모듈들을 참고하고 있음 => 즉, 작은 블록을 쌓아서 큰 성을 쌓는다! 설치한 다음에 require=import하면 된다.

const app = express(); // 그런 다음에 어플리케이션을 만드는 거지, express를 실행시켜 app에 담는다.

const PORT = 4000;

function handleListening() {

 console.log(`${PORT} Server ready...✅`);

}



app.listen(PORT, handleListening); // app아 너 듣고 있니? express 서버를 갖게 됬어!

<hr>

GET 요청은 바디가 없어서 정보를 담아서 전달하기에는 부족하다.

POST 요청은 정보를 담아서 전달할 수 있다.

<hr>

const express = require("express");

const app = express();



const PORT = 4000;



function handleListening() {

 console.log(`${PORT} Server ready...✅`);

}



function handleHome(req, res) {

 res.send("여기는 홈 페이지 입니다.");

}



function handleProfile(req, res) {

 res.send("여기는 프로파일 페이지 입니다.");

}



app.get("/", handleHome);

app.get("/profile", handleProfile);



app.listen(PORT, handleListening);     

//여기까지가 기본적으로 서버에 대해 요청과 응답이 이루어지는 기본적인 구조

하지만 그 다음부터는 res.send() 안에 완전한 html,css 파일을 넣어서 보내줄꺼다!

서버를 생성하고 route를 생성하고 그리고 그것에 대해 응답하는 것까지 했다.

여기까지 NodeJS, express를 이용해 코드 20줄로 만든것

그 다음부터는 Babel을 이용해서 Javascript 코드를 update하는데 쓸 거다.

왜냐면 최신의 Javascript 코드를 쓰고 싶기 때문에...

<hr>

Babel이란게 뭘까?

최신의 Javascript 코드를 예전의 Javascript 코드로 변환해준다!!



그니까 우리가 기본적으로 최신의 Javascript 코드를 작성하면 babel은 이걸 브라우저가 이해할 수 있는 표준의 코드로 바꿔주는 역할을 한다.



Babel은 많은 Loader를 가지고 있는데 이건 한마디로 babel을 쓰기 위해서 설치해야하는 모듈이라고 생각하면 될듯?(내생각)

Babel node는 babel을 NodeJS에서 쓰기 위해서 필요함



statge-3에 해당하는 걸 쓰면 브라우저가 절반만 받아들여질 것이다.

state-0는 완전 실험적인 걸 얻게 될것



하지만 우리는 preset-env를 쓸것임(이건 완전 실험적인것도 아니고 브라우저가 어느정도 이해를 함)



Babel도 우선 Nodejs가 어떻게 작동해야 하는지 알아야 하니까 @babel/core, @babel/node, @babel/preset-env등을 설치해준다.

npm install @babel/core

npm install @babel/node

npm install @babel/preset-env



npm install nodemon



일단 파일 하나 생성 .babelrc

.babelrc 파일생성해서 거기에 **우리가 원하는 NodeJS와 Javascript에 대한 설정과 관련된 것들을 넣어줄 것임



예를들어 이거야, "Babel아 넌 이런 preset을 가질꺼야"



package.json 의 start 부분에 추가해줄 것임

{

 "presets": [

  [

   "@babel/preset-env",

   {

​    "useBuiltIns": "usage",

​    "corejs": 3

   }

  ]

 ]

}

npm install --save core-js@3

.babelrc 파일의 preset에 내가 corejs:3버전을 쓴다고 했기 때문에 설치도 3버전을 설치해야 한다.



https://babeljs.io/docs/en/babel-preset-env





babel이 코드를 변환하면 우리가 작성한 최신의 자바스크립트 코드가 못생긴 코드로 바뀌고 그런 다음 node.js로 실행해주는 것이다.



이제 import express from "express"; 로 바꿔줘도 됨



npm start하면 서버가 가동 될 것임



express에 대해서 알아 둬야 할게 있어!

express에서 middleware라는 녀석은 처리가 끝날 때까지 연결되어있는 거라고 이해하면 됨

처리가 끝날 때까지 연결되어 있는 녀석 = middleware

그럼 request가 어떻게 시작돼고 



app.get("/")에서  슬래쉬 부분이 route의 시작이라고 할 수 있다. 슬래쉬만 있으면 처음 초기 home을 찾는다.



보통 연결은 그 흐름이 간단히 이루어 지지 않는다.

보통 중간에 뭔가가 있게 된다. middleware

유저와 마지막 응답 사이에!!!

그래서 express에서 모든 함수는 middleware가 될 수 있다.



const betweenHome = (req,res,next) =>{

console.log("미들웨어 한 번 거치고 그다음 next인 handleHome 함수 호출")

next();

}



양파를 생각해봐 양파의 껍질은 여러겹이지? 그 가장 바깥쪽이 사용자의 request라고 생각하면 그 다음 안쪽층은 middleware라고 생각하고 양파의 가장 중심이 마지막 응답이라고 생각해봐

이렇게 중간에서 함수들이 middleware 역할을 해줄 수 있다. 이게 날 편하게 만들어준다.

이런걸로 내가 로그인을 체크 할 수 있고

파일을 전송할 때 중간에서 가로챌 수도 있고오

그 middleware는 어딘가로 upload하겠지?

로그를 작성하는 middleware도 작성 가능

내가 만약 모든 요청에 대한 정보를 로그로 남기고 싶다면 그런 middleware를 작성하면 되는것



지금은 쉽게 betweenHome은 / 에 대해서만 미들웨어로 썼잖아? 그래서 하나의 route에만 미들웨어를 씀

app.use(betweenHome);   : 기본적으로 웹사이트에서 일어아는 모든 것에 대해 표시, 순서 중요!



접속이 있을 때

위에서부터 아래로 실행이 된다.

그래서 app.use(betweenHome);을 내가 다음에 쓰고 싶은 route 바로 직전에 위치 시켜놓던가 다음에 위치 시켜놓던가 위치 중요!



app.get("/",handleHome);

app.use(betweenHome);

app.get("/profile",handleProfile);



이렇게 돼있을때 미들웨어는 /profile에 대해서만 작동함





이제 Morgan이라는 미들웨어를 설치해보자

morgan은 logging에 도움을 주는 미들웨어

npm install morgan



index.js파일에서 import morgan from "morgan"; 선언



app.use(morgan("tiny"));

app.use(morgan("combined"));

app.use(morgan("dev"));



helmet이라는 미들웨어를 설치해보자

helmet 미들웨어는 NodeJS 앱의 보안에 도움이 되는 미들웨어

npm install helmet



index.js 파일에 import helmet from "helmet"; 추가



이건 뭐 보여주는건 많이 없지만 그냥 앱보안을 위해서 필요한거라고 생각하면 됨 습관을 위해서



미들웨어는 가끔은 연결을 끊을 수가 있다.



const middleware = (req,res,next)=>{

res.send("not happening");

}



위와같이 작성해 놓고 next(); 이렇게 안해주면 그 다음 함수까지 호출못하고 연결을 끊을 수 있다.





이제 2개 미들웨어만 남음

cookie-parser , body-parser 둘다 express의 middleware

이름 그대로 쿠키와 바디를 다루는 미들웨어!



기본적으로 누군가 form을 채워서 전송을 한다면 이 form은 서버에 의해서 받아져야만 한다. 특정한 형태로..

form을 받았을 때 그 데이터를 가지고 있는 request object에 접근할 수 있길 원해 그걸 위해 일단 npm install body-parser 설치 이건 body로부터 정보를 얻을 수 있게 해주는 것



npm install cookie-parser

cookie에 유저 정보를 저장



import bodyParser from "body-parser"

import cookieParser from "cookie-parser"



app.use(cookieParser());   // 이게 유저로부터 받은 cookie를 서버가 이해하는 방법

app.use(bodyparser());     // 이게 서버가 우리가 보내는 데이터의 정보의 형식을 알 수 있는 라인



body-parser에는 우리가 지정해야할 옵션이 있다. text라던지 urlencoded라던지

왜냐면 우리가 무엇을 전송할 때 서버가 무엇을 전송하는지 알 수 있어야 하니까!

우리가 json을 보낼 때 서버가 json을 이해하길 바래야겠지?



우리가 일반적인 html form을 전송한다면 서버가 urlencoded라는 걸 이해하길 바래야한다.

app.use(bodyParser.json());   //내가 보내는 json 데이터 서버가 이해할 수 있게끔 해줌

app.use(bodyParser.urlencoded({extended:true}));   // 내가 보내는 html form 서버가 이해할 수 있게끔



morgan이 기록해주고



이제부터 슬슬 복잡해지기 시작할 껀데 데이터베이스도 집어 넣어야 하고 설정도 해야 해서

init.js 파일 생성해주고

index.js => app.js 파일로 변경해주자



app.js 에서 app.listen 부분 지워주기



init.js 파일에서 모듈을 불러올 것임



모듈이라는게 있어서 우리 코드를 공유할 수 있다.

다른 파일에서의 코드를 가져다가 사용할 수 있다.



app.js를 init.js에서 사용하는것



app.js 파일 맨 아래에 export default app; 

export default app의 의미는 누군가 내 파일을 불러올 때(import) 내 app object를 주겠다라는 의미

app object라는게 뭔데? 그건 app.use 블라블라 app.get 이런 것들 전부를 의미, 내가 이미 설정한 것들





init.js 파일에서..

import app from "./app";

const PORT = 3000;



const handleListening = ()=>{

console.log(``)

}



app.listen(PORT,handleListening);



이미 application을 app파일에서 가져왔기 때문에 가능



<hr>

router란 route들의 복잡함을 쪼개주는데 사용할 수 있다.

/

/user

/user/profile

/user/changeProfile

등등등



router.js 파일 생성

import express from "express";

const userRouter = express.Router();



userRouter.get("/")

##home(/)에다가 함수를 하나 만들어 줄 것임

두가지 방법이 있는데

#### 1.route랑 분리해서 함수를 하나 만드는 방법

const handleHome = (res,res)=>{

res.send("Here is Home");

}

app.get("/",handleHome);



#### 2.익명의 함수로 만드는 방법 

userRouter.get("/",(req,res)=>{

res.send("Here is Home");

});

 

**둘다 같은건데 2번째꺼는 route안에 들어간거라서 편해보임**





import express from "express";

const userRouter = express.Router();

userRouter.get("/",(req,res)=>{res.send("user index")});

userRouter.get("/edit",(req,res)=>{res.send("user edit")});

userRouter.get("/password",(req,res)=>{res.send("user password")});



그럼 이 router들을 어떻게 app.js 파일에서 사용할까?

router.js 는 기본적으로 많은 route들이 담긴 파일이야

**export  const userRouter = express.Router();**를 해주면 app.js에서 import해와서 쓸 수 있다.



app.js 파일 상단에

import {userRouter} from "./router"; 선언



그리고 app.use("/user",userRouter); 이렇게 코딩

use의 의미는 누군가 /user 경로에 접속하면 userRouter를 사용하겠다. 즉, router 전체를 사용하겠다라는 의미



자 이제 접속을 해보자

localhost:3000/user

localhost:3000/user/edit

localhost:3000/user/password



그다음 MVC 패턴에 대해서 배우겠다.



MVC는 Mode, View, Control을 의미한다.

Model : 데이터

View : 데이터가 어떻게 생겼는지 보여주는 것

Control : 데이터를 보여주게 하는 함수



이건 뭔 설치나 그런걸 하는게 아니라 그냥 섹시한 구조& 패턴을 보여주는 컨셉인거임



이제 URL과 함수를 분리할 것이다.(데이터의 모습에 맞춰서 말야!)

URL에 해당하는 router를 사용하고 실행하는 함수가 Controller가 되겠지



우리가 하는 프로젝트에서는

Model : 데이터베이스 => mongoDB

View : templete => pug

Controller : 데이터 보여주는하는 함수

일단 MVC 에 맞게끔 분리를 해줘야 함



일단 app.js 파일에서 다음과 같은 코드 지워버리기

app.get("/",handleHome);

app.get("/profile",handleProfile)

handleHome,handleProfile 함수도 지워버리기





그 다음 userRouter.js 파일 생성하기

videoRouter.js 생성하기



다음과 같은 파일들을 routers 폴더를 만들어서 안에 집어 넣기

<hr>

**userRouter.js 파일 코드**

import express from "express";



const userRouter = express.Router();



userRouter.get("/", (req, res) => {

 res.send("user index");

});



userRouter.get("/edit", (req, res) => {

 res.send("user edit");

});



userRouter.get("/password", (req, res) => {

 res.send("user password");

});



export default userRouter;

<hr>

**videoRouter.js 파일 코드**

import express from "express";

const videoRouter = express.Router();

export default videoRouter;

<hr>

app.js 파일에

import userRouter from "./routers/userRouter";

import videoRouter from "./routers/videoRouter";



app.use("/user",userRouter);

app.use("/video",videoRouter);

추가



이거 말고도 글로벌 라우터 하나를 더 가질껀데 그건 globalRouter

globalRouter는 /join , /login , /home 이런걸 다룰꺼임



왜냐면 아직 home URL이 없거든



routers 폴더에 globalRouter.js 파일 추가 



app.js 파일에

app.use("/",globalRouter); 추가

누군가 root("/")로 접속하면 globalRouter를 찾겠지?



/logout은 user에서 다뤄야겠지?



globalRouter에서 다뤄야 될껄 잘 생각해봐

/home

/join

/about_page

/search



userRouter에서 다뤄야 할껀?

/edit

/profile

/password



videoRouter 는?

/upload

/record





**이 방법이 유일하게 독점적으로 URL을 다루는 방법이다!!!!**

globalRouter.js / userRouter.js / videoRouter.js 여기에 있는 것들은 URL만 다루는 것들이기 때문에

우리가 앞으로 작성해야할 함수와는 아무 상관이 없다.

globalRouter에 /join은 말이 안돼... 이런거랑은 상관없써 단지 URL뿐임 controller가 아니야~



<hr>

import express from "express";

import corejs from "core-js";

import morgan from "morgan";

import helmet from "helmet";

import bodyParser from "body-parser";

import cookieParser from "cookie-parser";



import userRouter from "./routers/userRouter";

import videoRouter from "./routers/videoRouter";

import globalRouter from "./routers/globalRouter";



const app = express();



const handleHome = (req, res) => {

 res.send("여기는 홈 페이지 입니다.");

};



const handleProfile = (req, res) => {

 res.send("여기는 프로파일 페이지 입니다.");

};



app.use(cookieParser());

app.use(bodyParser.json());

app.use(bodyParser.urlencoded({ extended: true }));

app.use(helmet());

app.use(morgan("dev"));



app.get("/", handleHome);

app.get("/profile", handleProfile);



app.use("/user", userRouter);

app.use("/videos", videoRouter);

app.use("/", globalRouter);



export default app;

<hr>



routes.js 파일 만들어주기 (Divide and Conquer)



userRouter.js 파일에다가 /user/id/edit 이렇게 작성하지 않겠어

왜냐면 나중에 다른 곳에서 같은 URL을 사용해야 할 수도 있기 때문에..

ex) Redirect to /user/id/edit 이렇게 쓴다면 내가 다른 어딘가에 쓰고 싶을 때 이구조를 외우고 있어야 함



그래서 단 하나의 source를 쓰려고 함 그게 routes.js 파일임

그래서 이 파일안에 명시를 다 해놓고 언제든지 URL을 불러와서 쓰게 할 것임

//Global한 영역

const HOME = "/";

const JOIN = "/join";

const LOGIN = "/login";

const LOGOUT = "/logout";

const SEARCH = "/search";



//USERS

const USERS = "/users";

const USER_DETAIL = "/:id";   //내가 요청을 할 때 /users/1 이렇게 하면 1번 user를 주는 것

const EDIT_PROFILE  = "/edit-profile";

const CHANGE_PASSWORD = "/change-password";



//Videos

const VIDEOS = "/videos";

const UPLOAD="/upload";

const VIDEO_DETAIL = "/:id";

const EDIT_VIDEO = "/:id/edit";

const DELETE_VIDEO = "/:id/delete";



"/:id"이렇게 한 이유는 express가 똑똑해서 이런 형태의 URL을 보면 이 값은 변화하는 값이구나를 알아차림

콜론 없이 id라고 치면 그냥 text로 인식함



이제 아래에 object를 만들자



const routes = {

home: HOME,

join:JOIN,

login:LOGIN,

logout:LOGOUT,

search:SEARCH,

users:USERS,

userDetail:USER_DETAIL,

editProfile:EDIT_PROFILE,

changePassword:CHANGE_PASSWORD,

videos:VIDEOS,

upload:UPLOAD,

videoDetail:VIDEO_DETAIL,

editVideo:EDIT_VIDEO,

deleteVideo:DELETE_VIDEO

};

이렇게 작성하고 객체를 export 해주자



export default routes;



app.js 파일에서 import routes from "./routes"; 해주고



app.use("/",globalRouter) => app.use(routes.home,globalRouter);

app.use("/users",userlRouter) =>app.use(routes.users,userRouter);

app.use("/videos",videoRouter) =>app.use(routes.videos,videoRouter);

로 변경



globalRouter.js / userRouter.js / videoRouter.js  각각 import routes from "../routes"; 해주기



<hr>

globalRouter.get(routes.home, (req, res) => {

 res.send("Here is Home");

});



globalRouter.get(routes.join, (req, res) => {

 res.send("Here is join page");

});



globalRouter.get(routes.login, (req, res) => {

 res.send("Here is login page");

});



globalRouter.get(routes.logout, (req, res) => {

 res.send("Here is logout page");

});



globalRouter.get(routes.search, (req, res) => {

 res.send("Here is search page");

});



globalRouter.get(routes.about, (req, res) => {

 res.send("Here is about page!");

});



이런거 나머지(userRouter,videoRouter도 똑같이~

<hr>

이제  이 구조에서 벗어나기 위해서 controller를 써줄 것임



controllers라는 새 폴더 생성



videocontroller와 usercontroller를 만들 것임



대개 프로젝트에 있는 각 모델마다 컨트롤러를 만들게 된다.



이 프로젝트에서는 video, 비디오를 업로드할 users 그리고 routes를 한번 보자



const HOME = "/"  이걸보면 HOME화면에는 비디오들이 전달될거다.

나중에는 comment 기능도 만들것임(comment는 video controller에 넣을 것임)



컨트롤러는 어떤 일이 어떻게 발생하는지에 관한 로직!!!!

여기에 있는 모든 함수들이지!!! 여기 이 함수들을 모두 컨트롤러에 담을 것임

그 함수들이 뭐냐면 userRouter.get(routes.home,(req,res)=>{res.send("HOME")}); 요런것들



videoController.js 와 userController.js를 만들자 그리고 여기에 많은 함수들을 추가 할 것임



추가할 함수 각각을 export할 것임 예를 들어, globalRouter에서 이 Home함수는 videoController로 이동 시킬 것임.



videoController 파일안에 다음과 같이 작성



export const home=(req,res)=>{res.send("Home")}

export const search=(req,res)=>{res.send("Search")}





join,login,logout 관련 작업을 userController에서 해보자



export const join=(req,res)=>{res.send("Join")}

export const login=(req,res)=>{res.send("Login")}

export const logout=(req,res)=>{res.send("Logout")}





그 다음 globalRouter.js로 돌아가서 

import {home,search} from "../controllers/videoController"; 선언하고



다음과 같이 globalRouter.get(routes.home, home); 변경



이렇게 바꿔주는 이유는 전과 같이 쓰면 나중에 로직이 복잡해지면 더 어려워지기 때문에

controller로 분할 해주는 것임



다른것들도 똑같이 해주자~



### Recap

init.js에는 app.js에서 import 한 application이 있다.

application 관련 코드들은 app.js 파일에 담겨 있다.



express를 import했고, express를 실행한 결과를 app상수로 만들었다.

그리고 미들웨어 추가



cookieParser는 cookie를 전달받아서 사용할 수 있도록 하는 미들웨어

사용자 인증 같은 곳에서 쿠키를 검사할 때 사용해야 하기 때문!!!



bodyParser는 사용자가 웹사이트로 전달하는 정보들을 검사하는 미들웨어

요청 정보에서 form이나 json형태로 된 body를 검사한다.



이건 우리가 아바타의 사진이나 비디오를 업로드 할 때, 제목이나 댓글 같은 정보를 전달할 때 form에 담아서 업로드 해야 하기 때문!!



helmet 미들웨어는 application이 안전할 수 있도록 만들어준다.



moragan 미들웨어의 역할은 application에서 발생하는 모든 일들을 logging 하는 미들웨어



그리고 router 3개를 사용할 것임



첫 번째로 globalRouter인데 , 이 안에는 /home, /search, /join, /login, /logout URL이 담겨있다.

두 번째로 userRouter 안에는 /users/ 주소들이 담겨있다.

세 번째로 videoRouter 안에는 /videos/ 주소들이 담겨있다.



주소들은 routes.js에 정의해뒀다. 한 파일이 바뀌면 모두 적용되도록 할 수 있다.!!!!!



**모든 router의 로직들은 모두 userController나 videoController에 정의되어 있다.**

controller에 들어간 것들은 다 함수들이다 join,login,logout 등을 리턴하고 있다.



arrow function은 기본적으로 (req,res)=>{return res.send("join")}이다.



그 다음에는 Pug를 설치할꺼다

pug는 express에서 View를 다루는 방식 중 하나임!!!



express로 HTML을 보여 줄 수 있다. res.send대신에 실제 HTML을 전달할 것임



css같은 것들로 꾸밀 수 있고 pug가 View이다.



HTML을 아주 멋져 보이도록 만들어준다.





Pug(express의 view engine = template 언어) - express에서 View(데이터)를 다루는 방식 중 하나 - 웹클라이언트에게 HTML을 전달 가능 - HTML을 꾸며주기도 함 - app.set()(application 설정 함수)를 사용하여 view engine을 undefined에서 pug로 변경   - pug & express의 view 파일들 위치 경로를 바꾸려면 set 함수의 name으로 'views' 주면 됨   - default는 views 폴더이므로 우리는 views 폴더 생성     - home.pug 생성 - 문법   - p : html p태그 생성 - controller에서 send 대신 render( 문자열)



express에서 어플리케이션을 셋팅할때는 set()함수를 써야한다.

set함수에는 name과 value가 필요하다

어플리케이션의 설정을 하는 함수!!!

우리는 view engine의 설정을 바꿀것임 view engine의 default값은 undefined이기 때문에 pug로 바꿔줄것임



pug와 express에는 view 파일들의 위치에 관한 기본 설정이 있어

만약 그 설정을 바꾸고 싶다면 'views'설정을 바꾸면 됨

어플리케이션의 화면이 담긴 디렉토리나 디렉토리의 배열을 입력하면 된다네?



html파일을 저장해야 하는 폴더의 기본 값은 **프로젝트 작업 디렉토리 + /views**이다.



views라는 이름의 폴더를 생성하자



여기에 html 파일 하나 생성 

우리는 pug를 쓸 것이기 때문에 확장자 .pug 붙이기

home.pug



pug는 템플릿 언어이다. express의 view engine 임



그러면 이 템플릿을 웹사이트에 보여주려면 어떻게 해야 할까?



컨트롤러에서 res.send로 join을 전송하는 것 대신에 말이야



res.send 대신에 res.render 함수 쓰면 된다.



컨트롤러에 res.render("home")이라고 하면 

render함수가 views 폴더에서 파일명이 home이고 확장자가 pug인 파일을 찾은 후에 보여준다.



아까 기본 값이 "작업 디렉토리+views폴더" 였잖아?

그러니까 express는 자동으로 views 폴더를 찾아가는거지

내가 view engine 값을 pug로 설정해 놨으니까

그리고 render함수에 의해서 확장자가 pug이고 파일 이름이 "home"인걸 찾겠지?



이제 많은 템플릿 파일과 view를 작성하게 될것임



HTML,CSS에 대해서만 알고 있었지만 계속 header,footer 같은 부분을 복사-붙여넣기 해야 하기 때문에 못생겼을 거야



일단 함수별로 pug 템플릿 파일 만들기



HTML 과 CSS 만으로만 작업할 때는 똑같은 것을 반복하는 경우가 많기 때문에 별로 좋지 않다.



HTML과 CSS는 프로그래밍 언어가 아니기 때문에 논리적인 작업에 적합하지 않다

복사-붙여넣기 하는게 고통스러움



pug와 같은 것들로 작업을 하면, html을 생성하는 javascript의 위력을 사용할 수 있다.

아주 좋은 능력이지



views 폴더 아래 각 함수기능별로 pug파일 작성하고

layout 폴더를 views 폴더 안에 만들기

layout 폴더 안에 main.pug 만들기

main.pug는 모든 페이지들의 토대가 되는 파일



main.pug 에서 extension을 할 것임

main도 사용하고 거기에 추가적인 것을 더하겠다는 뜻



home.pug에

extends layouts/main.pug 라는 코드를 추가

그러면 이제 home화면이 layouts/main.pug 코드를 복사-붙여넣기 한다는 뜻



그러면 이제 block content가 들어가는 자리에 내용들을 채워넣을 수 있어





<hr>

### partials : 페이지의 일부분

**include ../partials/header**

**include ../partials/footer**

조직적인 목적으로만 만들어지지

views 폴더안에 partials 폴더 만들고 그 안에

header.pug, footer.pug라는 파일을 만들자



footer에는 아이콘이 들어갈꺼야



연도 불러오는 거

#{new Date().getFullYear()}



로그아웃 상태라면

헤더에 join, login 버튼이 보여야겠지?



로그인 상태라면

헤더에 upload, profile, logout 버튼이 보여야겠지?



우리가 추가한 라우트들이 pug파일로 연결되면 좋겠어



즉, routes.js에 있는 객체들이 pug파일에 연결되면 좋겠지?

URL을 쓸 수 있고 말야





### one single source of truth(한 곳에서만 정보를 보관)=> 더 나은 코드를 만들어주는 원칙





이제 템플릿에 정보를 추가할 시간!



컨트롤러에 있는 정보를 템플릿에 추가하는 방법을 알아보자



한 템플릿에만 추가하거나, 전체 템플릿에 추가할 수 있다.



템플릿 전체에 추가하는 방법부터 설명하겠다.

헤더가 라우트 객체 접근하고 싶어?

이때 미들웨어를 사용해야 한다.

미들웨어는 레이어 같은것!!!

위에서 밑으로 한단계식 내려간다.





처음에 view engine을 pug로 설정했어 => helmet이 있고 cookie를 파싱하고,body에 담긴 정보를 파싱해 => 그 다음에 morgan이 있고, 그 이후에 컨트롤러와 라우트들이 있지

이제 locals라는 미들웨어를 만들어 볼것임

local 변수를 global변수로 사용하도록 만들어주는 거라고 생각하면 됀다.

그래서 local기능을 통해 변수에 접근할 수 있다.



app.use((req,res,next)=>{

});



app.use(function(req,res,next){

});



const localsMiddleware = (req,res,next)=>{

}



위에 3개 똑같은거야



가장 깔끔해보이는걸로 쓰면 됨

나는 3번째껄 사용할꺼야

<hr>

const localsMiddleware = (req,res,next) =>{

}

app.use(localsMiddleware);

<hr>

Divide and Conquer를 위해서 미들웨어 파일을 하나 만들자

middlewares.js 파일 생성



여기에 locals를 추가 할 것이다.

locals가 추가되면 이제 그것들을 템플릿, 컨트롤러,어디에서든 쓸 수 있다.



app.use(미들웨어)를 쓸때는 위치가 중요하니까 신경 잘 써야 한다!!!



local변수에 접근하기 위해서 localsMiddleware를 사용할 것이다!!!



항상 알파벳 순서로 import하면 좋다~



export const localsMiddleware = (req,res,next) =>{

res.locals.siteName = "Working at Home"

}



locals에 있는 건 템플릿에 변수명 처럼 존재해



다른 locals도 추가해보자

routes에 routes.js 객체를 추가할거다

res.locals.routes = **routes;(routes.js파일 안에있는 routes 객체)** 



<hr>

import routes from "./routes"

export const localsMiddleware = (req,res,next) =>{

res.locals.siteName = "Working at Home";

res.locals.routes = routes;

next();

}

<hr>

미들웨어가 커넥션과 라우트들 사이에 있으니까 next()를 꼭 해주기



vscode에서는 pug 자동완성 기능을 지원해 주지 않는다.





자아 locals에 로컬 변수를 저장하면, 이 변수들을 템플릿에서 사용할 수 있다!!!

템플릿을 직접 수정하지 않고, middleware.js에서 수정을 하면 된다.



나중에 사용자 데이터 관련한 정보를 locals에 저장 해볼것임



지금까지 전역적으로 사용할 수 있는 변수를 추가하는 방법을 알아봤다.

모든 템플릿에서 사용할 수 있고, 템플릿,뷰,모든 곳에서 사용가능



이 멋진 locals라는 미들웨어는 코드 사이에 들어가 있어서, next를 호출해야 한다.

next()함수는 다음 함수로 넘어간다는 뜻 

우리의 경우에는 다음에 있는 라우터들로 넘어간다는 말



locals를 이용해서 전역 범위에 변수를 추가하는 방법을 배워봤다.





자 이제 한 템플릿에만 변수를 추가하려면 어떻게 해야 할까?

템플릿마다 다른 정보를 가질 수도 있을 테니까



어떤 템플릿에는 비디오, 다른 템플릿에는 사용자, 또 다른 템플릿에는 프로필~





render 함수의 첫 번째 인자는 템플릿 이름이고 두번째 인자는 추가할 정보가 담긴 객체이다!



res.render("home", {pageTitle : "Home"});

pageTitle의 값은 Home으로 하겠다.