## 유닉스/리눅스 8강(p49~52)



### 터미널, 세션, 프로세스 그룹 개요



터미널이 유닉스 시스템에 접속하겠지?

인증 과정을 거쳐서 로그인 쉘이 기동이 되겠지?

그러면 세션이 생성이 된다.

**세션이란? 터미널과 유닉스 시스템 사이에 논리적인 연결 상태**

그리고 세션 아이디가 생김 SID



자아 로그인 쉘이 기동이 돼면 process 뿐만 아니라 process group도 생성이 된다.

process group도 필요하니까 생성이 됬겠지?

**Process Group : 터미널 제어권의 관리 단위로서 이걸 사용한다.**



터미널로 유닉스 시스템 접속 => 인증과정 => 세션생성(터미널-유닉스 논리적 연결상태)=>로그인 쉘 프로세스 생성 =>프로세스 그룹 생성(login shell process를 관리하는 작업단위)



로그인 쉘 프로세스는 leader process 가 되며 이게 PID가 되고 로그인 쉘 프로세스를 관리하는 Process Group의

PGID는 login shell pid가 된다. 



자 그다음은 Login Shell이 a.out 파일을 실행시키면 새로운 프로세스가 생성이 되겠지? 그리고 그 프로세스를 관리하는 Process Group도 생겨나겠지?



우리가 fork라는 시스템 콜을 발생시키면 복사본 프로세스를 만들어낸다.(copy process)

별도의 pid가 생성이 됨

그리고 exec("실행파일")을 실행시키면

프로세스 이미지 교체(전이)가 일어남 



정리해서 말해보자면...

부모 프로세스가 자식 프로세스를 여러개 만들어 낼 수 있잖아?

그러면 이 때 부모와 자식 프로세스들은 같은 Process Group으로 묶인다.

![image-20200321231738540](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200321231738540.png)





터미널 제어권은 크게 2가지로 나뉜다.

1.터미널 입력(Terminal Input)

2.터미널 발생 신호(Terminal Generator Signal)

 

터미널 제어권을 가지고 동작하는 모드를 **foreground Mode**라고 한다.

터미널 제어권 없이 동작하는 모드를 **background Mode**라고 한다.



우리가 일반적으로 프로세스가 포그라운드 모드로 동작하네 백그라운드 모드로 동작하네 이러는데 정확히 말하자면 **어떤 프로세스 그룹이 포그라운드 모드/백그라운드  모드로 동작하네 이래야 함**







<hr>

터미널에 대한 제어권을 가지고 동작하는 모드를 포그라운드 모드 제어권을 가지고 있는 프로세스 그룹을 포그라운드 프로세스 그룹이라 한다

터미널에 대한 제어권 없이 동작하는 모드를 백그라운드 모드라고하며 제어권이 없는 프로세스 그룹을 백그라운드 프로세스 그룹이라 한다. 

터미널과 연결되어 세션이 생성되면, 해당 세션 내에서는 하나의 포그라운드 프로세스 그룹과 하나이상의 백그라운드 프로세스 그룹이 생성.

<hr>



전반적인 흐름을 이해하자

1.터미널 접속에서 부터

2.세션이 생성되고

3.프로세스 그룹이 생성되고

4.프로세스가 생성이 되고

5.포그라운드 모드와 백그라운드 모드와 프로세스 그룹간의 관계를 알아야 한다.



pid가 뭐다?

ppid가 뭐다?

pgid가 뭐다?

sid가 뭐다?



외우지 말고 이해를 하고 설명할 수 있어야 한다.



실습을 해보자

터미널 접속

sleep 1000 &     <= &를 줬기 때문에 백그라운드로 동작 쉘한테 제어권이 있음



ps -o 옵션은 내가 원하는 필드를 명시해 줄 수 있다.

ps -o pid,ppid,pgid,sid,cmd

이걸 쳐봐서 나오는 것들을 완벽하게 숙지하고 있어야 한다.





#### 프로그램 실행 과정

![image-20200321233654548](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200321233654548.png)



1.쉘이 a.out을 실행시키고 fork()를 통해 copy process 생성 => 터미널 제어권이 자식 프로세스로 넘어간다. 

2.exec()를 통해 프로세스 전이를 시킴 => a.out으로 다시 터미널 제어권이 넘어감

3.a.out종료 및 터미널 제어권 쉘로 반환





유닉스에서는 모든 프로세스는 하나의 프로세스 그룹에 소속 되어있다. 쉘도 예외는 아니다.

![image-20200321234114825](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200321234114825.png)



다양한 관점에서 그림을 이해해 봐라!!!



실력이 있으면 자격증이 빛나는 거다.

몇마디 해보면 이사람이 실력이 있는지 없는지 알 수 있음





### 프로세스 간 통신(시그널)

**프로세스에게 특정 상황이 발생했음을 알리기 위한 비동기적 통지(Asynchronous Notification )**

시그널이라는 것은 프로세스에게 특정 상황이 발생했음을 알리기 위한 비동기적 통지이다.

<hr>

특정상황은 4가지 정도로 정리할 수 있음

### 1.Terminal에서 Generated Signal

​	**SIGINT**

​	**SIGQUIT**

​	**SIGTSTP**

실습 예시) 터미널에서 sleep 1000을 치면 내가 터미널 제어권을 뺏기잖아? 

이때 내가 시그널을 발생시킬 수 있다. ctrl+c를 누르면 SIGINT 발생하면서 종료시킴

이게 어떻게 된거냐면... sleep 프로세스가 돌아가고 있는데 SIGINT를 발생시키면 부모 노드인 sleep 입장에서는 



ctrl + z 는 종료를 시키는게 아니라 정지를 시키는 시그널임



프로세스가 정지 당하면 자동으로 백그라운드 모드로 들어가게 되있음

당연히 터미널 제어권을 백그라운드 당한 프로세스가 가지고 있으면 안돼잖아.



jobs 명령어를 통해서 현재 프로세스들 상태를 볼 수 있음



fg %2 : fg %job_number를 치면 정지당한 프로세스를 다시 살려줄 수 있다.

job_number는 jobs치면 맨앞에 나오는 숫자가 job_number이다.

<hr>

### 2.Hardware 적인 예외상황

메모리 참조오류 SIGSEGU

산술 연산 오류 SIGFRE

<hr>

### 3.Software 적인 예외상황

SIGCHILD

<hr>

### 4.Kill 명령 or 시스템 콜





**특정상황을 커널이 알려줄 수도 있고 다른 프로세스가 알려줄 수도 있고 자기 자신 프로세스일수도 있다. 그래서 프로세스간 통신을 IPC라고도 얘기하는 것임(서로 서로 뭔가 상호작용 한다는 의미인 것 같음)**



### 

kill -9 3000 = kill -KILL 3000



kill -l : 시그널 목록을 볼 수 있음



많은 시그널이 있지만 2개만 중요하게 보자

SIGKILL

SIGSTOP

이 2개는 관리 목적의 시그널



기본적인 시그널 처리 방식은 아래와 같이 3개 처리를 한다.

1.시그널 handling

2.시그널 ignore

3.시그널 default



그러나, SIGKILL과 SIGSTOP은 개별 프로세스가 절대 처리하지 못하는 시그널이다.

이건 관리 목적의 시그널이기 때문에 무조건 default 동작으로 들어간다.



상황을 생각해보자.

만약 악성프로그램이 돌고 있다. 이걸 죽여야 해

만약 SIGKILL, SIGSTOP 시그널이 무조건 default로 실행이 안된다면

악성 프로그램 입장에서 코드로 저런 시그널이 들어오면 난 저걸 무시할꺼야 이러면 

큰일 나잖아? 그래서 SIGKILL이나 SIGSTOP은 default로 무조건 실행돼야 함

