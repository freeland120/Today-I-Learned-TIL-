## Unix/Linux 기본학습/p30~31

### 4) 입출력 재지정(I/O Redirection) : 쉘에서 지원해주는 기능중에 하나

1.프로그램을 실행시키면 모든 프로세스는 기본적으로 3개의 파일이 오픈된다.

 a. 표준입력(표준입력을 의미하는 식별값 : 0 파일디스크립터 )

 b. 표준출력(1)

 c. 표준에러(2)

여기서 0,1,2가 의미하는건 파일디스크립터 식별값!, 값은 고유하다.

파일을 계속열면 4,5... 이렇게 증가한다. 

기본적으로 3가지 파일이 열림



근데 여기서 '입출력 재지정'이란 것은 키보드로 들어오는 입력을 파일에서 받도록 대체하는 것



원래는 표준입력,표준출력으로 나갔는데 이것을 파일로 돌리겠다. 

ps > output.dat



'>' : 리다이렉션 기호



출력 redirection은 실무에서 많이 쓰임

ps  >> output.dat 은 append 모드로 동작을 한다. 꺽쇠가 2개잖아 추가된다는 느낌이 있지~

원래 표준 출력 쓸때는 이렇게 쓰는건데 1이 생략된거임

ps 1> output.dat



ps asdfsd 2>error.dat    (에러를 error.dat 파일로 보내겠다)



ps 1>output.dat 2>error.dat



실무적으로 많이 쓰이는 거 알려줄께

일단 쉘을 하나 만들고~

cat batch.sh



우리가 실무적으로 업무를 하다보면 긴 시간동안 작업하는 프로그램을 돌릴때가 있다.

이때 내가 터미널을 끄게되면 프로그램이 종료되는 경우가 발생

왜냐 터미널이 끊어지면 SIGHUP이라는 시그널이 발생 시그행업이라고 읽나보네잉

그래서 행업 시그널이 발생해도 이걸 무시하겠다라는 명령어로 'nohup'을 쓴다.

nohup ./batch.sh 이렇게 하면 이제 이 쉘은 행업시그널이 발생해도 종료되지 않는다.



nohup ./batch.sh 1> /dev/null 

(행업시그널이 발생해도 무시해버리고 표준출력이나 표준에러로 나가는 메세지를 다 버려버려라

여기서 null 디바이스(특수 장치파일)는 윈도우의 휴지통이랑 똑같다. 내가 뭔가 출력되는 데이터를 버리고 싶을 때 null 디바이스로 보내면 버릴 수가 있다.



nohup ./batch.sh 1> /dev/null >2&1 (띄어쓰기 조심)

이걸보자 원래 리다이렉션 기호 뒤에는 파일명이 나오는데 이건 &1이 나왔지?

이건 파일명을 지정안하고 파일 디스크립터를 지정할 수 있다.

그런데 이게 파일명인지 디스크립터인지 모르니까 &기호를 붙여서 이건 파일 디스크립터입니다를 알려주는 것



결국, 긴 작업을 해야할 때 nohup이라는 명령어를 자주 사용한다. (실무에서 많이 사용)

output redirection 많이 사용하니까 꼭 이해하고 넘어가기~





### 5)파이프(pipe) : 이것도 쉘에서 지원해주는 매우매우 중요한 기능

이걸 알기위해서는 사전 배경이 필요함

### 1. IPC(Inter-Process-Communication) : 프로세스간 통신 기법

이게 왜나왔냐? 어떤 프로세스가 기동을하면 이 프로세스에게 물리적인 메모리를 바로 할당해 주는게 아니야 가상메모리 기법을 이용해서 할당한다.

가상메모리 기법이란 실제 물리적으로 부족한 메모리를 확장해서 사용하는 OS의 기법 

process -> 가상메모리 

(Virtual Address Space할당)

실제 물리적인 공간을 할당하는게 아니라 가상의 메모리 공간을 할당하는 것이다.

a라는 프로세스의 100번지와 b라는 프로세스의 100번지가 같을까? X

서로 고유한 가상메모리 공간을 사용하기 때문 



그래서 기본적으로 가상메모리를 사용하게 되면 **프로세스간 통신이 불가능하다.**

만약, 프로세스간 통신을 하고 싶다면 프로세스 자체적으로는 할수가 없다!!!



생각을 해봐 a라는 프로세스가 b한테 100번지 주소를 사용해라고 한다면 서로 바라보는 100번지 주소가 같은데 어떻게 알아먹겠어 그래서 중재자가 필요함 이게 "커널"이 할 수가 있음



가상메모리 기법을 사용하는 이유

1.물리적인 주소공간을 극복하고자

2.OS의 안전성을 위해서 : 다시말해, 각자 프로세스간에 고유한 메모리공간을 가지고 있기 때문에 서로 침범할 수가 없다. / 어떤 프로세스가 다른 프로세스의 메모리를 읽으면 보안성 문제가 있을 수 있다.



그래서, 커널이 제공해주는 가장 전통적인 프로세스간 통신이 "pipe"이다.

(유닉스 초창기 때부터 존재해온 pipe 통신 기법)

ex.) A라는 프로세스가 B라는 프로세스와 통신을 하고 싶어 그러면 기본적으로 커널이 pipe를 만드는데 당연히 이 때 "시스템콜"이라는 것을 통해 커널한테 요청해야 한다.(pipe를 만들고 싶어요~)

프로세스가 커널의 자원을 사용하고 싶을 때 쓰는 호출 : 시스템 콜(실제로는 시스템 함수)

사용자 프로그램은 직접 커널에 접근할 수 없으며, 시스템 호출(System call)을 통해 커널에 접근한다.
시스템 호출은 프로세스가 운영체제 커널에게 어떤 동작을 수행토록 요청하는 것을 의미

![image-20200316210358283](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200316210358283.png)

### 2. System V 계열 유닉스 만든 IPC -> 모든 유닉스 시스템

a. Shared Memory

커널이 메모리 영역을 잡아주는데... 그래서 그 메모리 영역에다가 프로세스간에 같이 쓸 수 있도록 만들어주는 게 shared memory이다.

b.Message Queue(메세지를 전달해 줄 수 있는 큐를 만드는 것)

c.Semaphore(세마포어) : 애는 정보를 주고받는다기 보다는 프로세스간의 동기화를 하기위한 개체, 프로세스간의 접근 순서를 맞춰는 개체라고 이해하면 될듯



**입력문법(command1|command2) : 선행프로세스의 표준출력을 후행프로세스의 표준입력으로 넣어주겠다.**

$ ls -l | more



pipe는 프로세스간의 통신기법인데 쉘에서 지원해주는 이 pipe의 기법은 선행프로세스의 표준출력을 후행프로세스의 표준 입력으로 넣어준다!!!!!





grep이라는 명령어는 파일로부터 데이터를 읽어 그러면 뒤에 있는 문자열(vsttpd) 패턴을 가지고 있는 행을 출력해주는 명령어



$ps -ef | grep vsftpd

결국 이 명령어는 ps결과를 받아서 그 행중에 vsftpd라는 문자열이 들어가있으면 출력을 해라



more라는 명령어는 화면단위로 보고 싶다.(화면단위로 끊어서 보고 싶다)

ps -ef | more 이렇게 치면 ps 결과를 받아서 more로 뿌려준다.



### 6)특수문자(쉘에서 사용되는 특수문자)

![image-20200316212116217](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200316212116217.png)

ps

id

이렇게 명령어 따로따로 입력하기 보다는

ps;id 이렇게 쉘 명령어 구분자를 넣어서 한꺼번에 해줄 수도 있다.

';' 의미는 앞에 있는 명령어 실행하고 뒤에있는 명령어 실행해라 뭐 이런 의미

ps;id;ls 순차적으로 명령어를 실행



';'을 해커가 악용할 수도 있다.

ping -c 4 127.0.0.1;cat /etc/passwd



명령어를 연속해서 실행할 수 있는 기호는 많다.

;

&

or

pipe 등

 '>>' : append 기능