## 유닉스/리눅스 7강 (p45-48)

### 프로세스 개요

1.프로세스가 생성되면 커널/운영체제는 개별 프로세스별로 관리정보를 담고 있는 프로세스 제어블럭(PCB)을 생성한다.

**프로세스 제어블록(PCB/Process Control Block)**

a. 프로세스 상태

b. 프로세스 번호 : 프로세스 식별하기 위한 번호(ID)

c. 프로세스 카운터 : 문맥교환이 발생할 경우 다음에 실행할 명령어의 위치값 저장

d. 레지스터 : 문맥교환이 발생할 경우 "현재 프로세스의 실행 상태정보를 저장"

(레지스터란? CPU가 연산을 수행하기 위한 고속의 저장장치)

e. 메모리 정보 :  프로세스가 사용하는 메모리 page 또는 segment 테이블 정보

![image-20200321113842499](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200321113842499.png)

**프로세스 상태 전이도**

생성 ,준비, 대기, 종료





Context Switching(문맥 교환)

CPU를 차지하고 있었던 프로세스가 CPU자원을 반환하고 새로운 프로세스가 CPU자원을 할당 받는 것을 context switching이라고 한다.



명령어를 수행하는 단위를 instruction이라고 한다.

여기까지는 사용자 영역을 본거다 그다음부터는 커널의 영역 관점에서 보겠다.



커널/운영체제가 시스템 내에서 여러 프로세스들에 의해 오픈된 파일들을 관리하기 위한 자료구조가 System open-file tables이다.

a. open_mode : 파일의 읽기/쓰기 모드

b. offset : 현재 파일 I/O를 수행하기 위한 위치값

c. reference_count : 해당 파일의 참조 갯수를 의미한다. 파일 복제가 발생하게 되면 reference_count가 증가한다.



(나) 프로세스 기본 조건

pid, ppid과의 관계를 알아보자 ,z,o

fork();라는 함수는 자식 프로세스를 생성해주는 함수이다.

 ![image-20200321115908707](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200321115908707.png)



**유닉스/리눅스 시스템에서 모든 프로세스는 부모 프로세스(parent process)를 가진다. 부모가 없는 프로세스는 없다. 최초의 프로세스가 init프로세스** 

ps -ef | grep init | grep -v grep

여기서 init은 프로세스이다.

init 프로세스의 중요한 역할 2가지

1.run-level에 따른 시스템 초기화(run-level에 설정돼있는 초기 프로세스를 구동)

2.대리모 역할 수행





kill -9 4703 : "SIGKILL"메세지를 날려주면서 종료시킴 프로세스틀



각 프로세스들은 왜 부모 프로세스가 존재해야 하는걸까?

프로세스 종료 시에는 자신의 종료상태정보를 부모 프로세스에 반환해야 정상적으로 소멸 할 수 있다.



유닉스/리눅스 시스템에서 기본 조건중에 하나는**"모든 프로세스는 부모 프로세스를 가지고 만약 부모 프로세스가 종료되게 된다면 자식 프로세스는 고아 프로세스가 된다. 이때 init 프로세스가 고아가 된 프로세스들의 대리모 역할을 수행하게 된다."**





프로세스가 코드수행을 다 했다고 해서 프로세스가 바로 종료되는 것이 아니다. 내가 작업을 다 마쳤다고 커널에 알려줘야 하고 이 정보를 "종료상태정보"라고 한다.

그리고 커널은 부모 프로세스에게 SIGCHILD를 통해서 알려줌

부모 프로세스는 미리 만들어 놓은 signal-handler를 동작시켜 그 정보를 커널로부터 가져온다.

어찌됬든 자식 프로세스가 종료를 하려면 결국 부모 프로세스가 커널로부터 종료 상태 정보를 가져가야 그 다음에 커널이 종료를 시켜 줄 수 있뜸

![image-20200321122028269](C:\Users\KAUstar\AppData\Roaming\Typora\typora-user-images\image-20200321122028269.png)



자식프로세스가 작업을 다 수행했지만 소멸하지 않고 남아있는 이유는 아직 커널이 관리 정보를 가지고 있기 때문에 이 프로세스의 상태를 "좀비 상태"라고 한다.

이렇게 되면 제한된 시스템의 자원 문제로 가용성에 대한 문제가 발생 할 수 있다.



ps -l 명령어로 프로세스 좀비상태 파악할 수 있씀

<defunct>가 "존재하지 않는"이라는 의미



**ps -l 필드의 의미**

F : 프로세스 플래그

#### S : 프로세스의 현재 상태

	1. R : 프로세스가 실행 중 이거나 점유하기 위해 대기 중인 상태
 	2. S : 인터럽트 가능한 sleep 상태
 	3. D : 인터럽트가 불가능한 sleep상태(일반적으로 IO 대기 중 상태)
 	4. T : 프로세스가 정지된 상태(stopped)
 	5. Z : 좀비 상태의 프로세스(Zombie)



PRI : 우선순위

NI : 우선순위를 가감해주는 값

ADDR : 프로세스 메모리 주소

SZ : 프로세스가 차지하는 메모리의 크기

WCHAN : sleeping 상태의 프로세스가 대기하는 커널 함수 명





터미널에서 ./a.out & 이렇게 치면 실행한 파일이 백그라운드에서 작동을 함 & 기호가 백그라운드에서 작동하고 터미널의 제어권을 다시 돌려줌



kill -l 을 통해서 시그널 리스트를 볼 수 있다.



ps -f : 해당 쉘에서 실행시킨 프로세스만 볼 수 있다.

ps -ef : 전체 시스템에서 실행시킨 프로세스를 볼 수 있다.



init 프로세스는 대리모 역할도 하지만 더 중요한 기능은 부팅의 마지막 단계에서 초기화를 담당하는 역할이 더 크다.



gcc test.c : test.c 파일을 컴파일하는 명령어



ps -f

ps -l

명령어 다 쳐봐 그리고 봐봐