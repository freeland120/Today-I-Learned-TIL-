

   # SQL 자격검정 실전문제 #


-------------------------------------------------------------------------------------------------------

 1과목 - (1)


 8.  가장 중요한 엔터티 왼쪽 상단에 배치. (왼쪽 상단에서 조금 아래쪽 중앙)
 12. 기본, 중심, 행위
 21. 관계명, 관계차수, 관계선택사양
 26. 식별자 특성 암기


 1과목 - (2)


 31. 성능 데이터모델링을 하면서 데이터 모델의 구조도 변경될 수 있다.
 36. 정규화, 몇:몇 관계 개념 확인
 37. 도메인 원자값 말고도 칼럼의 중복도 1차 정규화 대상
 38. 37번과 동일 (칼럼의 중복 = 1차 정규화 대상)
 40. 다량의 데이터 탐색 = 반정규화 보다는 파티셔닝 및 클러스터링 먼저 고려
 46. 논리적으로 하나, 물리적으로 여러개로 분할 = 파티셔닝
 47. 슈퍼/서브타입 데이터모델 통합/분리 변환 개념 확인
 51. 조인이 빈번할 경우 FK에도 인덱스 설정, DB에 FK 제약조건 설정 안해도 조인 필요 시 인덱스 설정 O
 52. GSI (Global Single Instance) = 통합된 한 개의 인스턴스. 즉, 통합 데이터베이스 구조를 의미.
      (분산 데이터베이스와는 반대되는 개념)

                                                                                                                      1회차 48 / 52   92점
                                                                                                                      2회차 52 / 52  100점

-------------------------------------------------------------------------------------------------------

 2과목 - (1)


 4.  비절차적 데이터 조작어 = 무슨 데이터를 원하는지만 기술. 어떻게 접근 → 절차적 언어 (TL/SQL)
 7.  ALTER TABLE 테이블명 MODIFY 컬럼명 (SQL Server = ALTER COLUMN 컬럼명)
 9.  FK의 ON DELETE CASCADE 옵션 = 연결된 행 자체가 삭제됨
 12. 칼럼 선언 때 PK 선언 후 PK 제약조건을 또 생성하면 오류 발생
 16. ALTER TABLE 테이블명 DROP COLUMN 칼럼명;
 18. RENAME 테이블명 TO 새테이블명;
 19. DEPENDENT = Master 테이블에 PK 존재할 경우만 Child 입력 허용 / [ 해설지 참조동작 암기 ]
 21. VARCHAR2 타입 칼럼에 숫자 타입 입력 가능
 22. [ON DELETE SET NULL]로 설정되어 있어도 칼럼에 NOT NULL 제약조건 있을 경우 삭제 불가.
 23. DELETE FROM 테이블명 (DELETE 경우, SELECT처럼 * 쓰지 않음, FROM 생략 가능)
 28. Dirty Read = 다른 트랜잭션에 의해 수정되었지만 아직 커밋되기 전 데이터 읽음, 
      Non-Repeatable Read = 같은 쿼리 두 번 수행중 중간에 다른 트랜잭션이 값을 수정 또는 삭제,
      Phantom Read = 첫 번쨰 쿼리에서 없던 유령 레코드가 두 번째 쿼리에서 나타남.
 37. VARCHAR2 타입 칼럼에 모든 데이터가 숫자형식으로 입력되어 있으면 숫자형식 조회 가능
      INSERT INTO ~ VALUES 에서 ''로 값 입력 시, Oracle은 IS NULL로, SQL Server는 [ 컬럼 = '' ] 로 조회
 39. [ TO_DATE('2020', 'YYYY') 또는 TO_DATE('202005', 'YYYYMM') ] 
      → 월 생략시 현재 월, 일 생략시 1일이 디폴트 값.
 40. 1:M 관계의 두 테이블을 조인할 경우에도 단일행 함수를 사용할 수 있다.
      (M쪽에서 출력된 행이 하나씩 단일행 함수의 입력값으로 사용되므로)
 41. REPLACE(문자열, (구)문자, (신)문자) = 문자열에서 해당 (구)문자를 (신)문자로 전부 교체
      ((신)문자 값 입력 안할 시, (구)문자 전부 제거)
 42. 1/24/60 = 1분
 45. 칼럼의 NULL값을 확인할때는 IS NULL 사용. (칼럼명 = NULL 사용불가. X)
      INSERT 구문으로 [ '' ] 삽입시, Oracle은 NULL로, SQL Server는 '' 공백문자 그대로 테이블에 입력됨.
 51. GROUP BY 시 기준 칼럼에 NULL 값들이 있을 경우 NULL 그룹도 하나로 묶여 집계되어 출력됨.
 53. 그룹함수 중첩사용 불가 [AVG(COUNT(*)) 그룹당 1개 값이 나오는데 평균 구할 수 없음]
 56. GROUP BY 절 이후, [그룹대상 칼럼]과 [집계함수가 사용된 집계칼럼] 외의 다른 칼럼은 사용할 수 없다.

                                                                                                                      1회차 52 / 64   80점
                                                                                                                      2회차 61 / 64   94점

-------------------------------------------------------------------------------------------------------

 2과목 - (2)


 65.  순수관계 = SELECT, PROJECT, JOIN, DIVISION
       일반집합 = 합집합(Union), 교집합(Intersect), 차집합(Except), 곱집합(Cross Join/Cartesian Product)
 66.  EXISTS 절은 존재 유무만 판단. SELECT 절 의미 X (FROM 절에서 WHERE 조건에 해당하는 것 조회)
 67.  관계선택사양 대응관계 숙지
 70.  Using 절에는 접두사 및 Alias 사용 불가. (Only 칼럼명만 기술)
 73.  문제 확인 (OUTER JOIN 여러가지 표현 방법)
 77.  Oracle에서 (+) 기호 붙은 반대방향쪽 OUTER JOIN. 조건 여러개에 (+) 표시 있을 시,
       ON절에 포함하여 함께 작성.
 79.  칼럼 A, B에 대하여 각각 NOT IN을 사용하였기 때문에 결과가 다르게 나옴. (묶어서 Not In 해야 함)
 80.  1번은 GROUP BY를 하지 않아 사용횟수만큼 여러 건이 출력 됨.
 82.  SQL 문장에서 같은 칼럼의 ALIAS가 여러 개 선언될 시, 첫 모듈에 선언된 ALIAS를 적용.
 86.  3번이 답 맞는데 결과 칼럼 수가 똑같다는 소리가 아니라 COUNT(*). 즉, 건(행)수가 같다는 말이므로 문제 없음.
 90.  Oracle에서 PRIOR 구문 CONNECT BY뿐 아니라 SELECT, WHERE 절에서도 사용 가능.
 93.  문제 확인 (집계 함수로 윈도우펑션 기능 구현)
 94.  SELECT COUNT(DISTINCT A||B) → A+B 조합에 대하여 DISTINCT (A+B의 값으로 중복 값 제거 후 카운트)
 95.  다중컬럼 서브쿼리는 SQL Server에서 지원 X
 97.  3번 회원A 테이블과 동의항목B 테이블 간에 회원번호 일치 조건이 없어서 동의'N' 1명만 있어도 조건이 TRUE 됨.
 98.  회원ID 일치 조건이 없으면 [회원별로] 이메일 발송 건수를 [카운트하지 않기 때문에] 3번 답 안됨.
 99.  다중행 서브쿼리의 비교 연산자는 단일행 서브쿼리의 비교 연산자로도 사용할 수 있다 ( ex. IN → = 대신 가능 )
 100. 스칼라 서브쿼리 = JOIN으로 동일한 결과 추출 가능, 인라인 뷰 = 동적 뷰
 101. 최종 회차만 조건으로 조회해야함 ( 3, 4번은 칼럼들 개별로 MAX 값 각각 조회 )
 103. 실제 데이터를 저장하고 있는 뷰를 생성하는 기능을 지원하는 DBMS도 있음.
 108. 일반 그룹 함수로 [ 큐브, 롤업, 그룹핑셋 ] 셋 모두와 동일한 결과 추출 가능
       그룹핑 함수들의 집계 대상 칼럼 중 집계된 칼럼 이외의 대상 칼럼은 NULL값을 반환함.
 109. 큐브, 롤업, 그룹핑셋 결과 테이블 양식 숙지할 것
 112. 윈도우함수는 결과에 대한 함수처리이기 때문에 결과 건수에는 영향 X
 114. 게임상품ID별로 파티션 잡아줘야해서 4번 (문제 보기에서 'ROWNUM <= 10' 구문은 누락예상)
 116. PARTITION 대신 GROUP BY로 대체 사용 가능
 118. LAG(인수, 몇번째, NULL 대체값) → 인수의 몇 번째 전의 행 값 (몇번째 생략시 디폴트 값 1개)
 119. GRANT, REVOKE
 123. PL/SQL 변수, 상수 이용하여 WHERE절의 조건 등으로 사용 가능 (사용자 정의 함수 = select, from, where 절 등)
       TRIGGER 제외 프로시저, 사용자 정의 함수는 작성자 기준으로 트랜잭션 분할 가능. (TCL 사용 가능)
       또한 프로시저 내에서 다른 프로시저 호출시 호출 프로시저의 트랜잭션과는 별도로
       [ PRAGMA AUTONOMOUS_TRANSACTION ]을 선언하여 자율 트랜잭션 처리를 할 수 있다.
       → 자율트랜잭션 (부모 블록과 별개로 자식 블록의 트랜잭션 commit/rollback = 로그 기록을 남길 때 주로 사용)
 124. TRUNCATE TABLE은 DDL로 분류 가능. (Auto Commit 특성)
       PL/SQL에서 DDL과 동적SQL 실행시에는 앞에 execute immediate 사용.
 126. Trigger = 데이터베이스 로그인 작업에도 정의 가능, TCL 사용불가 → 트랜잭션 제어/분할 불가능.

                                                                                                                      1회차 46 / 63   72점
                                                                                                                      2회차 61 / 63   96점

-------------------------------------------------------------------------------------------------------

 2과목 - (3)


 133. 인덱스 범위 스캔은 0~N건 반환
 134. 보조 인덱스는 UNIQUE INDEX가 아니면 중복값 가능
 135. 대량의 데이터를 삽입할 때는 인덱스 제거 후 삽입한 뒤에 인덱스 재생성
 136. BITMAP 인덱스 = DW, AD-HOC 질의 환경, 하나의 키 많은 행 포인터
 137. 인덱스 범위 스캔 0건 반환 가능
 138. B-TREE 인덱스는 전체 10% 미만 소량 검색시 유리 (일치 및 범위 검색)
 139. B-TREE 인덱스는 일치 및 범위 검색에 적절한 구조
 140. SQL Server 클러스터형 인덱스는 Oracle의 IOT와 유사 ( IOT = Index-Organized Table ), 
       UPDATE시에는 인덱스 부하 없을 수도 있음 (인덱스가 포함되지 않은 수정)
 141. NL조인 = [ OLTP 목록 처리 업무 / 온라인 / 소량 ], [ DW등 집계 업무 / 대량 ] = Sort Merge, Hash Join
 142. NL조인 = 자연조인 효율적일 때, 소량 테이블 온라인 조회할 때
 143. IN, EXISTS 절은 주로 SEMI JOIN ( 앞에 NOT 붙으면 ANTI SEMI JOIN )
 145. 해싱 사용 = 적당한 인덱스 X (자연조인 비효율), 동등 조인만 가능. (해쉬 함수 사용하기 때문)
       자연조인시 드라이빙 액세스량 많아 Random 액세스 부하 심할 때
 146. JOIN KEY로 정렬되어있을 때 제외 일반적으로 Hash Join이 Sort Merge Join보다 우수함.

                                                                                                                      1회차 16 / 19   84점
                                                                                                                      2회차 19 / 19  100점

--------------------------------------------------------------------------------------------------------

  # 교재 문제 및 답지 확인 (유형 파악) #


   [ 1 과목 ]

   26번, 36번, 40번, 46번, 47번


   [ 2 과목 ]

   7번, 19번, 67번, 73번, 90번, 93번, 95번, 98번, 101번, 109번, 118번, 124번, 136번, 143번

--------------------------------------------------------------------------------------------------------
